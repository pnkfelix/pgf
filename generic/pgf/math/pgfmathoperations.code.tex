% Copyright 2007 by Mark Wibrow
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

% This file defines the mathematical functions and operators.
%
% Version 0.0 08/03/2007

% Adding/redefining extra operators/functions:
%
% Each operator/function XXX has two forms:
%
%
% \pgfmathXXX#1...   a public version which evaluates any
%                    arguments passed to it and passes the
%                    results on to...
%
% \pgfmathXXX@#1...  a non-public version which performs 
%                    required calculation on arguments which
%                    must have already been evaluated (i.e.
%                    *without* dimensions).
% 
% If a function XXX is to be included in the parser, it is 
% recommended, for consistency, that where possible, the 
% pgfmathparser file should define the macro \pgfmath@parseXXX.
% The parser should (ideally) then call \pgfmathXXX@.
%
% It is recommend that the pgfmath versions of the pgf dimension
% and count registers be used, i.e., \pgfmath@x for \pgfmath@x, 
% \c@pgfmath@counta for c@pgfmath@counta, and so on. These are currently
% \let to their pgf equivalents, but it may be necessary to change 
% this.
%
% It is also recommened that all calculations (where necessary)
% take place within a TeX group. \pgfmath@returnone#1 makes and
% expanded version of #1 global and stores this in \pgfmathresult 
% after the group is ended.
%
\input{pgfmathtrig.code.tex}% Load the trig. stuff.
\input{pgfmathrnd.code.tex}%  Load the random stuff.

% \pgfmathadd
%
% Add #1 and #2.
%
\def\pgfmathadd#1#2{%
	\pgfmathparse{#1}\let\pgfmath@adda=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@addb=\pgfmathresult%
	\pgfmathadd@{\pgfmath@adda}{\pgfmath@addb}}
\def\pgfmathadd@#1#2{%
	\begingroup%
		\pgfmath@x=#1pt\relax%
		\pgfmath@y=#2pt\relax%
		\advance\pgfmath@x by\pgfmath@y%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathsubtract
%
% Subtract #2 from #1.
%
\def\pgfmathsubtract#1#2{%
	\pgfmathparse{#1}\let\pgfmath@subtracta=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@subtractb=\pgfmathresult%
	\pgfmathsubtract@{\pgfmath@subtracta}{\pgfmath@subtractb}}

\def\pgfmathsubtract@#1#2{%
	\begingroup%
		\pgfmath@x=#1pt\relax%
		\pgfmath@y=#2pt\relax%
		\advance\pgfmath@x by-\pgfmath@y%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathmultiply
%
% Multiply #1 by #2.
%
\def\pgfmathmultiply#1#2{%
	\pgfmathparse{#1}\let\pgfmath@multiplya=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@multiplyb=\pgfmathresult%
	\pgfmathmultiply@{\pgfmath@multiplya}{\pgfmath@multiplyb}}
\def\pgfmathmultiply@#1#2{%
	\begingroup%
		\pgfmath@x=#1pt\relax%
		\pgfmath@x=#2\pgfmath@x%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathdivide
%
% Divide #1 by #2.
%
\def\pgfmathdivide#1#2{%
	\pgfmathparse{#1}\let\pgfmath@dividea=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@divideb=\pgfmathresult%
	\pgfmathdivide@{\pgfmath@dividea}{\pgfmath@divideb}}
\def\pgfmathdivide@#1#2{%
  \begingroup%
    \pgfmath@x#1pt\relax%
    \pgfmath@ifinteger{#2}{%
      \afterassignment\pgfmath@gobbletilpgfmath@%
      \c@pgfmath@counta#2\relax\pgfmath@%
      \divide\pgfmath@x\c@pgfmath@counta}{%
      \pgfmathreciprocal@{#2}%
      \pgfmath@x=\pgfmathresult\pgfmath@x%
    }%
    \pgfmath@returnone\pgfmath@x%
  \endgroup%
}

% \pgfmathgreaterthan
%
% 1.0 if #1 > #2. Otherwise 0.0
%
\def\pgfmathgreaterthan#1#2{%
	\pgfmathparse{#1}\let\pgfmath@greaterthana=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@greaterthanb=\pgfmathresult%
	\pgfmathgreaterthan@{\pgfmath@greaterthana}{\pgfmath@greaterthanb}}
\def\pgfmathgreaterthan@#1#2{%
	\begingroup%
		\pgfmath@x#1pt\relax%
		\advance\pgfmath@x-#2pt\relax%
		\ifdim\pgfmath@x>0pt\relax%
			\pgfmath@x1pt\relax%
		\else%
			\pgfmath@x0pt\relax%
		\fi%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathlessthan
%
% 1.0 if #1< #2. Otherwise 0.0
%
\def\pgfmathlessthan#1#2{%
	\pgfmathparse{#1}\let\pgfmath@lessthana=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@lessthanb=\pgfmathresult%
	\pgfmathlessthan@{\pgfmath@lessthana}{\pgfmath@lessthanb}}
\def\pgfmathlessthan@#1#2{%
	\begingroup%
		\pgfmath@x#1pt\relax%
		\advance\pgfmath@x-#2pt\relax%
		\ifdim\pgfmath@x<0pt\relax%
			\pgfmath@x1pt\relax%
		\else%
			\pgfmath@x0pt\relax%
		\fi%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathequalto
%
% 1.0 if #1 = #2. Otherwise 0.0
%
\def\pgfmathequalto#1#2{%
	\pgfmathparse{#1}\let\pgfmath@equaltoa=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@equaltob=\pgfmathresult%
	\pgfmathadd@{\pgfmath@equaltoa}{\pgfmath@equaltob}}
\def\pgfmathequalto@#1#2{%
	\begingroup%
		\pgfmath@x#1pt\relax%
		\advance\pgfmath@x-#2pt\relax%
		\ifdim\pgfmath@x=0pt\relax%
			\pgfmath@x1pt\relax%
		\else%
			\pgfmath@x0pt\relax%
		\fi%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathreciprocal
%
% 1 / #1
%
\def\pgfmathreciprocal#1{%
	\pgfmathparse{#1}%
	\pgfmathreciprocal@{\pgfmathresult}}
\def\pgfmathreciprocal@#1{%
	\begingroup%
		\pgfmath@x=#1pt\relax%
		\ifdim\pgfmath@x=0pt\relax%
			\pgfmath@error{Division by zero}{}%
		\fi%
		\edef\pgfmath@temp{\pgfmath@tonumber{\pgfmath@x}}%
		% If #1 is an integer, no fancy approximation is needed.
		\pgfmath@ifinteger{\pgfmath@temp}{%
			\afterassignment\pgfmath@gobbletilpgfmath@%
			\c@pgfmath@counta=\pgfmath@temp\relax\pgfmath@%
			\pgfmath@x=1pt%
			\divide\pgfmath@x by\c@pgfmath@counta}{%
				% Oh well, here goes...
				%
				% ...approximate root...
				\c@pgfmath@counta=\pgfmath@x\relax%
				\divide\c@pgfmath@counta by65535\relax%
				\ifnum\c@pgfmath@counta=0\relax%
					\c@pgfmath@counta=1\relax%
				\fi%
				\pgfmath@x=1pt\relax%
				\divide\pgfmath@x by\c@pgfmath@counta\relax%
				% ...and now iterate..
				%
				\pgfmath@xb=\pgfmath@x%
				\pgfmathloop%
					\pgfmath@xa=-\pgfmath@temp\pgfmath@x\relax%
					\advance\pgfmath@xa by2pt\relax%
					\pgfmath@xa=\pgfmath@tonumber{\pgfmath@x}\pgfmath@xa%
					\pgfmath@x=\pgfmath@xa%
					% If the the root is the same as the last root...
					\ifdim\pgfmath@x=\pgfmath@xb% Stop!
					\else%
						\pgfmath@xb=\pgfmath@x%
					\repeatpgfmathloop}%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}%

% \pgfmathabs
%
% Calculate |#1|
%
\def\pgfmathabs#1{%
	\pgfmathparse{#1}%
	\pgfmathabsolute@{\pgfmathresult}}
\def\pgfmathabs@#1{%
	\begingroup%
		\pgfmath@x=#1pt\relax%
		\ifdim\pgfmath@x<0pt\relax%
			\pgfmath@x=-\pgfmath@x%
		\fi%
	\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathmod
%
% Calculate #1 mod #2.
%
\def\pgfmathmod#1#2{%
	\pgfmathparse{#1}\edef\pgfmath@moda{\pgfmathresult}%
	\pgfmathparse{#2}\edef\pgfmath@modb{\pgfmathresult}%
	\pgfmathmod@{\pgfmath@mod@a}{\pgfmath@modb}%
}
\def\pgfmathmod@#1#2{%
	\begingroup%
		\pgfmath@x#1pt\relax%
		\pgfmath@xa\pgfmath@x%
		\pgfmath@xb#2pt\relax%
		\c@pgfmath@counta=\pgfmath@xa%
		\c@pgfmath@countb=\pgfmath@xb%
		\divide\c@pgfmath@counta\c@pgfmath@countb%
		\multiply\pgfmath@xb\c@pgfmath@counta%
		\advance\pgfmath@x-\pgfmath@xb%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathsqrt
%
% Square-root of #1.
%
%
\def\pgfmathsqrt#1{%
	\pgfmathparse{#1}%
	\pgfmathsqrt@{\pgfmathresult}}
\def\pgfmathsqrt@#1{%
	\begingroup%
		\pgfmath@x=#1pt\relax%
		\pgfmath@x=.01\pgfmath@x%
		\pgfmath@xa=\pgfmath@x%
		\pgfmath@xb=\pgfmath@x%
		\pgfmathloop
			\pgfmath@xc=\pgfmath@x%
			% If pgfmath@x >= 128pt, we get an Arithmetic overflow, so...
			% If x^2 >= 16384 then 16384/x < x
			\pgfmath@y=16383.99999pt\relax%
			\c@pgfmath@counta=\pgfmath@x%
			\divide\c@pgfmath@counta by655360\relax% Can't remember why we need the extra zero.
			\ifnum\c@pgfmath@counta=0\relax%
				\c@pgfmath@counta=1\relax%
			\fi%
			\divide\pgfmath@y by\c@pgfmath@counta%
			\ifdim\pgfmath@y<\pgfmath@x%
			\else%
				\pgfmath@x=\pgfmath@tonumber{\pgfmath@x}\pgfmath@x%
				\advance\pgfmath@x by-\pgfmath@xa\relax%
				\pgfmath@ya=\pgfmath@x%
				\pgfmathreciprocal@{\pgfmath@tonumber{\pgfmath@xc}}%
				\pgfmath@x=\pgfmathresult\pgfmath@ya%
				\pgfmath@x=-.5\pgfmath@x%
				\advance\pgfmath@x by\pgfmath@xb%
			\fi%
			% If the new root equals the old root, stop.
			\ifdim\pgfmath@x=\pgfmath@xb%
			\else%
				\pgfmath@xb=\pgfmath@x%
		\repeatpgfmathloop%
		\pgfmath@x=10.0\pgfmath@x%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}

% \pgfmathpower
%
% Calculates #1 ^ #2
%
% #2 is expected to be an integer.
%
\def\pgfmathpower#1#2{%
	\pgfmathparse{#1}\let\pgfmath@powera=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@powerb=\pgfmathresult%
	\pgfmathpower@{\pgfmath@powera}{\pgfmath@powerb}}
\def\pgfmathpower@#1#2{%
	\begingroup%
		\pgfmath@xa#1pt\relax%
		\pgfmath@xb#2pt\relax%
		% If #2 is negative, take the reciprocal of #1
		% and the absolute value of #2, and carry on.
		%
		\ifdim\pgfmath@xb<0pt\relax%
			\pgfmath@xb-\pgfmath@xb%
			\pgfmathreciprocal@{\pgfmath@tonumber{\pgfmath@xa}}%
			\pgfmath@xa\pgfmathresult pt\relax%
		\fi%
		\afterassignment\pgfmath@gobbletilpgfmath@%
		\expandafter\c@pgfmath@counta\expandafter=\the\pgfmath@xb\relax\pgfmath@% Gobble decimal place.
		\pgfmath@x=1pt\relax%
		\pgfmathloop%
			\ifnum\c@pgfmath@counta>0\relax%
				\ifodd\c@pgfmath@counta%
					\pgfmath@x=\pgfmath@tonumber{\pgfmath@x}\pgfmath@xa%
				\fi
				% If \pgfmath@xa*\pgfmath@xa >=16384pt we get an error, so...		
				\pgfmath@xc=16383.99999pt\relax%
				\pgfmath@y=\pgfmath@xa%
				\ifdim\pgfmath@y<0pt\relax%
					\pgfmath@y=-\pgfmath@y%
				\fi%
				\c@pgfmath@countb=\pgfmath@y%
				\divide\c@pgfmath@countb by 65536\relax%
				\ifnum\c@pgfmath@countb=0\relax%
					\c@pgfmath@countb=1\relax%
				\fi%
				\divide\pgfmath@xc by\c@pgfmath@countb%
				\ifdim\pgfmath@xc<\pgfmath@y%
					\c@pgfmath@counta=0\relax%
				\else%
					\pgfmath@xa=\pgfmath@tonumber{\pgfmath@xa}\pgfmath@xa%
					\divide\c@pgfmath@counta by 2\relax%
				\fi%
		\repeatpgfmathloop%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}	


% \pgfmathround
% 
% Half-up rounding.
%
\def\pgfmathround#1{%
	\pgfmathparse{#1}%
	\pgfmathround@{\pgfmathresult}}
\def\pgfmathround@#1{%
	\begingroup%
		\pgfmath@x#1pt\relax%
		\afterassignment\pgfmath@gobbletilpgfmath@%
		\expandafter\c@pgfmath@counta\the\pgfmath@x\relax\pgfmath@%
		\pgfmath@y\pgfmath@x%
		\advance\pgfmath@y-\c@pgfmath@counta pt\relax%
		\pgfmath@x\c@pgfmath@counta pt\relax%
		\ifdim\pgfmath@x<0pt\relax%
			\advance\pgfmath@x-1pt\relax%
		\fi%
		\ifdim\pgfmath@y<0.5pt\relax%
		\else%
			\advance\pgfmath@x1pt\relax%
		\fi%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}%

% \pgfmathfloor
% 
% Floor function.
%
\def\pgfmathfloor#1{%
	\pgfmathparse{#1}%
	\expandafter\pgfmathfloor@\expandafter{\pgfmathresult}}
\def\pgfmathfloor@#1{%
	\begingroup%
		\pgfmath@x#1pt\relax%
		\afterassignment\pgfmath@gobbletilpgfmath@%
		\expandafter\c@pgfmath@counta\the\pgfmath@x\relax\pgfmath@%
		\pgfmath@x\c@pgfmath@counta pt\relax%
		\pgfmath@returnone\pgfmath@x%
	\endgroup
}%

% \pgfmathceil
% 
% Ceiling function.
%
\def\pgfmathceil#1{%
	\pgfmathparse{#1}%
	\expandafter\pgfmathceil@\expandafter{\pgfmathresult}}
\def\pgfmathceil@#1{%
	\begingroup%
		\pgfmath@x#1pt\relax%
		\afterassignment\pgfmath@gobbletilpgfmath@%
		\expandafter\c@pgfmath@counta\the\pgfmath@x\relax\pgfmath@%
		\pgfmath@y\pgfmath@x%
		\advance\pgfmath@y-\c@pgfmath@counta pt\relax%
		\pgfmath@x\c@pgfmath@counta pt\relax%
		\ifdim\pgfmath@y>0pt\relax%
			\advance\pgfmath@x1pt\relax%
		\fi%
	\pgfmath@returnone\pgfmath@x%
	\endgroup%
}%

% \pgfmathexp
%
% A Maclaurens expansion for e^#1.
% 0 <= #1 < ln(16384).
%
\def\pgfmathexp#1{%
	\pgfmathparse{#1}%
	\expandafter\pgfmathexp@\expandafter{\pgfmathresult}}
\def\pgfmathexp@#1{%
	\begingroup%
		\pgfmath@x1pt\relax%
		\pgfmath@xa1pt\relax%
		\pgfmath@xb\pgfmath@x%
		\pgfmathloop%
			\pgfmath@xc\pgfmathcounter pt\relax%
			\c@pgfmath@counta\pgfmath@xc%
			\divide\c@pgfmath@counta65536\relax%
			\pgfmath@xc1pt\relax%
			\divide\pgfmath@xc\c@pgfmath@counta%
			\pgfmath@xa\pgfmath@tonumber{\pgfmath@xc}\pgfmath@xa%
			\pgfmath@xa#1\pgfmath@xa%
			\advance\pgfmath@x\pgfmath@xa%
			\ifdim\pgfmath@x=\pgfmath@xb%
			\else%
				\pgfmath@xb\pgfmath@x%
		\repeatpgfmathloop%
	\pgfmath@returnone\pgfmath@x%
	\endgroup%
}



% \pgfmathvectorlength
%
% Calcluate the Eulidean length of a 2D vector.
%
% This based on polynomial approximation co-efficents
% contributed by Rouben Rostamian.
%
% #1 - the x component of the vector.
% #2 - the y component of the vector.
%
% P(x) = c0 + x^2 * (c1 + x^2 * (c2 + x^2 * ( c3 + c4 * x^2)))
\def\pgfmath@cE{-0.01019}
\def\pgfmath@cD{0.04453}
\def\pgfmath@cC{-0.11951}
\def\pgfmath@cB{0.49936}
\def\pgfmath@cA{1.00001}

\def\pgfmathveclen#1#2{%
	\pgfmathparse{#1}\let\pgfmath@vecx=\pgfmathresult%
	\pgfmathparse{#2}\let\pgfmath@vecy=\pgfmathresult%
	\pgfmathveclen@{\pgfmath@vecx}{\pgfmath@vecy}%
}
\def\pgfmathveclen@#1#2{%
	\begingroup%
		\pgfmath@x#1pt\relax%
		\pgfmath@y#2pt\relax%
		\ifdim\pgfmath@x>\pgfmath@y%
			\pgfmath@xa\pgfmath@x%
			\pgfmath@x\pgfmath@y%
			\pgfmath@y\pgfmath@xa%
		\fi%
		% We use a scaling factor to reduce errors.
		\ifdim\pgfmath@y>10000pt\relax%
			\c@pgfmath@counta1500\relax%
		\else%
			\ifdim\pgfmath@y>1000pt\relax%
				\c@pgfmath@counta150\relax%
			\else%
				\ifdim\pgfmath@y>100pt\relax%
					\c@pgfmath@counta50\relax%
				\else%
					\c@pgfmath@counta1\relax%
				\fi%
			\fi%
		\fi
		\divide\pgfmath@x by\c@pgfmath@counta\relax%
		\divide\pgfmath@y by\c@pgfmath@counta\relax%
		\pgfmathreciprocal{\pgfmath@tonumber{\pgfmath@y}}%
		\pgfmath@x=\pgfmathresult\pgfmath@x%
		\pgfmath@xa=\pgfmath@tonumber{\pgfmath@x}\pgfmath@x%
		\edef\pgfmath@xsq{\pgfmath@tonumber{\pgfmath@xa}}%
		\pgfmath@x=\pgfmath@cE\pgfmath@xa%
		\advance\pgfmath@x by\pgfmath@cD pt\relax%
		\pgfmath@x=\pgfmath@xsq\pgfmath@x%
		\advance\pgfmath@x by\pgfmath@cC pt\relax%
		\pgfmath@x=\pgfmath@xsq\pgfmath@x%
		\advance\pgfmath@x by\pgfmath@cB pt\relax%
		\pgfmath@x=\pgfmath@xsq\pgfmath@x%
		\advance\pgfmath@x by\pgfmath@cA pt\relax%
		\ifdim\pgfmath@y<0pt\relax%
			\pgfmath@y=-\pgfmath@y%
		\fi%
		\pgfmath@x=\pgfmath@tonumber{\pgfmath@y}\pgfmath@x%
		% Invert the scaling factor.
		\multiply\pgfmath@x by\c@pgfmath@counta\relax%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
}