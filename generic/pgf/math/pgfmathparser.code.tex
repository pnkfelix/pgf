% Copyright 2007 Mark Wibrow
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

% This file parses/evaluates a decimal expression.
%
% Version 1.414213 29/9/2007

% \pgfmathparse, \pgfmathqparse
%
% Evaluates a decimal expression.
%
% #1 - the expression.
%
% returns
%
% x = the result as a dimension.
%
% E.g.
% \pgfmathparse{3pt*2cm+1.5}
% \pgfmathqparse{3pt*2cm+1.5pt}
%
% Every number in \pgfmathqparse *must*
% specify a unit.
%
\newif\ifpgfmath@quickparse

%\def\pgfmathparse{%
%	\pgfmath@quickparsefalse%
%	\pgfmathparse@}

\newif\ifpgfmathfloat

\def\pgfmathparse{%
	\pgfmath@quickparsefalse%
	\ifpgfmathfloat%
		\let\pgfmath@parse@next\pgfmathfloatparsenumber%
	\else%
		\let\pgfmath@parse@next\pgfmathparse@%
	\fi%
	\pgfmath@parse@next}

\def\pgfmathqparse{%
	\pgfmath@quickparsetrue%
	\pgfmathparse@}

% Stuff for compatability with the calc package.
%
\def\pgfmath@calc@real#1{#1}
\def\pgfmath@calc@minof#1#2{min(#1,#2)}
\def\pgfmath@calc@maxof#1#2{max(#1,#2)}
\def\pgfmath@calc@ratio#1#2{#1/#2}
\def\pgfmath@calc@widthof#1{widthof(#1)}
\def\pgfmath@calc@heightof#1{heightof(#1)}
\def\pgfmath@calc@depthof#1{depthof(#1)}

\def\pgfmathparse@#1{%
  \begingroup%    
    % Reinstall correct font, so that dimensions like 1em are correct
    \pgfmath@selectfont%
    \let\real=\pgfmath@calc@real%
    \let\minof=\pgfmath@calc@minof%
    \let\maxof=\pgfmath@calc@maxof%
    \let\ratio=\pgfmath@calc@ratio%
    \let\widthof=\pgfmath@calc@widthof%
    \let\heightof=\pgfmath@calc@heightof%
    \let\depthof=\pgfmath@calc@depthof%
    \edef\pgfmath@temp{#1}%
    \pgfmath@resetparsingparameters%
    \global\pgfmathunitsdeclaredfalse%
    \ifpgfmath@quickparse%
      \let\pgfmath@parse@operand=\pgfmath@qparse@operand%
    \else%
      \let\pgfmath@parse@operand=\pgfmath@parse@operand%
    \fi%
    \let\pgfmath@parse@postgroup\pgfmath@parse@operator%
    \expandafter\pgfmath@parse@\pgfmath@temp @@@@@@@@@@@\pgfmath@empty}
    

% \pgfmath@resetparsingparameters
%
% Reset the stack at the begining of the parse/group.
%
\def\pgfmath@resetparsingparameters{%
	\pgfmath@stack{\pgfmath@empty\pgfmath@empty\pgfmath@empty\pgfmath@empty}%
	\def\pgfmath@stacknextoperator{\pgfmath@empty}% Will not work with \let
}

% Check to see if the parse starts with a TeX-group.
%
\def\pgfmath@parse@{\futurelet\pgfmath@token\pgfmath@parse@@}

\def\pgfmath@parse@@{%
	\ifx\pgfmath@token\bgroup% 
		\let\pgfmath@next=\pgfmath@parse@@@%
	\else%
		\let\pgfmath@next=\pgfmath@parse@@@@%
	\fi%
	\def\pgfmath@token{}%
	\pgfmath@next}%
	
% Remove any surrounding braces.
%
\def\pgfmath@parse@@@#1{\expandafter\pgfmath@parse@@@@#1}%

% Start parsing. Expect one of
%
% 1) the end of the parse.
% 2) the start of a group. 
% 3) a (possible) operand.
%
\def\pgfmath@parse@@@@#1{%
	\def\pgfmath@token{}%
	\ifx#1@%
		\let\pgfmath@parse@next=\pgfmath@parse@end%
	\else%
		\ifx#1(%
			\let\pgfmath@parse@next=\pgfmath@parse@startgroup%
		\else%
			\edef\pgfmath@token{#1}%
			\let\pgfmath@parse@next=\pgfmath@parse@operand%
	\fi\fi%
	\pgfmath@parse@next%
}

% If no TeX units are declared *at any point* in the parse
% the result is scaled by \pgfmathresultunitscale.
\newif\ifpgfmathunitsdeclared
\newif\ifpgfmathignoreunitscale
\def\pgfmathsetresultunitscale#1{\def\pgfmathresultunitscale{#1}}
\def\pgfmathresultunitscale{1}

% \pgfmath@parse@end
%
% Everything stops here.
%
\def\pgfmath@parse@end#1\pgfmath@empty{%
    \pgfmath@processalloperations%
    \pgfmath@stackpop{\pgfmathresult}% 
    \pgfmathpostparse%
    \pgfmath@smuggleone{\pgfmathresult}%
  \endgroup%
  \ignorespaces%
}


\def\pgfmathscaleresult{%
	\ifpgfmathunitsdeclared%
  \else%
  	\ifpgfmathignoreunitscale%
  	\else%
   	  \afterassignment\pgfmath@gobbletilpgfmath@%
      \pgfmath@x\pgfmathresultunitscale pt\relax\pgfmath@%
      \expandafter\pgfmath@x\pgfmathresult\pgfmath@x%
      \edef\pgfmathresult{\pgfmath@tonumber{\pgfmath@x}}%
    \fi%
  \fi%
}

\let\pgfmathpostparse=\pgfmathscaleresult
 
% \pgfmath@parse@startgroup
%
% When opening ( is scanned start a new group.
%
\def\pgfmath@parse@startgroup{%
	\begingroup%
		\let\pgfmath@parse@postgroup\pgfmath@parse@operator%
		\pgfmath@resetparsingparameters%
		\pgfmath@parse@}

% \pgfmath@parse@endgroup
%
% When closing ) is scanned, processes all waiting
% operations (within the group) and close the group.
%
\def\pgfmath@parse@endgroup{%
		\pgfmath@processalloperations%
		\pgfmath@stackpop{\pgfmathresult}%
		\pgfmath@smuggleone{\pgfmathresult}%
	\endgroup%
	\pgfmath@parse@postgroup%
}

% \pgfmath@parse@operator
%
% An operator is expected here. 
% Or the end of the parse or parse group.
% 
\def\pgfmath@parse@operator#1{%
	\def\pgfmath@token{}%
	% Push the operand in \pgfmathresult on to the stack. 
	\expandafter\pgfmath@stackpushoperand\expandafter{\pgfmathresult}%
	\ifx#1@%
		\let\pgfmath@parse@next\pgfmath@parse@end%
	\else%
		\ifx#1+%
			\let\pgfmath@parse@next\pgfmath@parse@add%
		\else%
			\ifx#1-%
				\let\pgfmath@parse@next\pgfmath@parse@subtract%
			\else%
				\ifx#1*%
					\let\pgfmath@parse@next\pgfmath@parse@multiply%
				\else%
					\ifx#1/%
						\let\pgfmath@parse@next\pgfmath@parse@divide%
					\else
						\ifx#1)%
							\let\pgfmath@parse@next\pgfmath@parse@endgroup%
						\else%
							\ifx#1r%
								\let\pgfmath@parse@next\pgfmath@parse@radians%
							\else%
								\ifx#1>%
									\let\pgfmath@parse@next\pgfmath@parse@greaterthan%
								\else%
									\ifx#1<%
										\let\pgfmath@parse@next\pgfmath@parse@lessthan%
									\else%
										\if#1=%
											\let\pgfmath@parse@next\pgfmath@parse@equalto%
										\else%
											\if#1^%
												\let\pgfmath@parse@next\pgfmath@parse@power%
											\else%
												\pgfmath@error{Unknown operator `#1'}%
												\let\pgfmath@parse@next\relax%
	\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi%
	\pgfmath@parse@next%
}

% Use a \toks register as a stack.
\newtoks\pgfmath@stack

% \pgfmath@stackpushoperator
% 
% Push an operator (actually its macro e.g., \pgfmathadd@)
% on to the stack. And keep track of it using the macro
% \pgfmath@stacknextoperator.
%
\def\pgfmath@stackpushoperator#1{%
	\edef\pgfmath@temp{\noexpand#1\the\pgfmath@stack}%
	\expandafter\pgfmath@stack\expandafter{\pgfmath@temp}%
	\def\pgfmath@stacknextoperator{#1}}% <- Must \def. Cannot \let.

% \pgfmath@stackpushoperand
%
% Push an operand (i.e. a number) on the stack. It is
% put within a TeX group to make popping a lot simpler.
%
\def\pgfmath@stackpushoperand#1{%
	\def\pgfmath@temp{{#1}}%
	\expandafter\expandafter\expandafter\def%
		\expandafter\expandafter\expandafter\pgfmath@@temp%
			\expandafter\expandafter\expandafter{\expandafter\pgfmath@temp\the\pgfmath@stack}%
	\expandafter\pgfmath@stack\expandafter{\pgfmath@@temp}%
}

% \pgfmath@stackpeek
%
% Peek (i.e. without removal) at the top of the stack.
%
\def\pgfmath@stackpeek{\expandafter\pgfmath@stackpeek@\the\pgfmath@stack\pgfmath@}
\def\pgfmath@stackpeek@#1#2\pgfmath@{#1}%

% \pgfmath@stackpop
%
% Pop (i.e. remove) the top of the stack into #1.
%
\def\pgfmath@stackpop#1{\expandafter\pgfmath@stackpop@\expandafter#1\the\pgfmath@stack\pgfmath@}
\def\pgfmath@stackpop@#1#2#3\pgfmath@{\def#1{#2}\pgfmath@stack{#3}}%

% \pgfmath@stackpopoperation
%
% Remove and perform an operation from the stack.
%
\def\pgfmath@stackpopoperation{%
	\expandafter\pgfmath@stackpopoperation@\the\pgfmath@stack\pgfmath@%
}
\def\pgfmath@stackpopoperation@#1#2#3#4#5\pgfmath@{%
	\ifx\pgfmath@empty#1\relax%
			\pgfmath@stack{\pgfmath@empty\pgfmath@empty\pgfmath@empty\pgfmath@empty}%
	\else%
		\ifx\pgfmath@empty#2\relax%
			\pgfmath@stack{{#1}\pgfmath@empty\pgfmath@empty\pgfmath@empty\pgfmath@empty}%
		\else%
			#2{#3}{#1}%
			\pgfmath@stack{#4#5}%
			\expandafter\pgfmath@stackpushoperand\expandafter{\pgfmathresult}%
	\fi\fi%
	\def\pgfmath@stacknextoperator{#4}}

% \pgfmath@processalloperations
%
% Process all operation in the stack. The 
% overall result is at the top of the stack.
%
\def\pgfmath@processalloperations{%
	\expandafter\pgfmath@in@\pgfmath@stacknextoperator{\pgfmath@empty}%
	\ifpgfmath@in@%
		\let\pgfmath@processnext\relax%		
	\else%
		\pgfmath@stackpopoperation%
		\let\pgfmath@processnext\pgfmath@processalloperations%
	\fi%
	\pgfmath@processnext}

% \pgfmath@processoperationsuntil
%
% Process operations in the stack, until the specified
% operation/s is/are encountered. The overall result is 
% at the top of the stack.
%
\def\pgfmath@processoperationsuntil#1{%
	\expandafter\pgfmath@in@\pgfmath@stacknextoperator{#1\pgfmath@empty}%
	\ifpgfmath@in@%
		\let\pgfmath@processnext\pgfmath@processoperationsuntil@end%		
	\else%
		\pgfmath@stackpopoperation%
		\let\pgfmath@processnext\pgfmath@processoperationsuntil%
	\fi%
	\pgfmath@processnext{#1}}
\def\pgfmath@processoperationsuntil@end#1{}


% OK. Now the operators are parsed.
% These correspond to the + - / * ^ < > = operators and r (postfix) function.
%
\def\pgfmath@parse@add{%	
	% If no operator has been assigned (i.e. + is the first operator scanned),
	% do nothing, except add addition to the stack.
	\ifx\pgfmath@stacknextoperator\pgfmath@empty%
	\else%
		% Empty the process stack up to any inequalities.
		\pgfmath@processoperationsuntil{\pgfmathequalto@\pgfmathlessthan@\pgfmathgreaterthan@}%
	\fi%
	\pgfmath@stackpushoperator{\pgfmathadd@}%
	\pgfmath@parse@}
	
\def\pgfmath@parse@subtract{%	
	% If no operator has been assigned (i.e. - is the first operator scanned),
	% do nothing, except add subtract to the stack.
	\ifx\pgfmath@stacknextoperator\pgfmath@empty%
	\else%
		% Empty the process stack up to any inequalities.
		\pgfmath@processoperationsuntil{\pgfmathequalto@\pgfmathlessthan@\pgfmathgreaterthan@}%
	\fi%
	\pgfmath@stackpushoperator{\pgfmathsubtract@}%
	\pgfmath@parse@}
	
\def\pgfmath@parse@multiply{%
	% If no operator has been assigned (i.e. * is the first operator scanned),
	% do nothing, except push multiply onto the stack.
	\ifx\pgfmath@stacknextoperator\pgfmath@empty%
	\else%
		% Process all operations up to inequalites or addition/subtraction
		\pgfmath@processoperationsuntil{\pgfmathequalto@\pgfmathlessthan@\pgfmathgreaterthan@%
			\pgfmathadd@\pgfmathsubtract@}%
	\fi%
	\pgfmath@stackpushoperator{\pgfmathmultiply@}%
	\pgfmath@parse@}
	
\def\pgfmath@parse@divide{%
	% If no operator has been assigned (i.e. / is the first operator scanned),
	% do nothing, except push divide onto the stack.
	\ifx\pgfmath@stacknextoperator\pgfmath@empty%
	\else%
		% Process all operations up to inequalites or addition/subtraction
		\pgfmath@processoperationsuntil{\pgfmathequalto@\pgfmathlessthan@\pgfmathgreaterthan@%
			\pgfmathadd@\pgfmathsubtract@}%
	\fi%
	\pgfmath@stackpushoperator{\pgfmathdivide@}%
	\pgfmath@parse@}

\def\pgfmath@parse@greaterthan{%
	% On scanning an equality/inequality operator everything up to
	% (but not including) the operator is evaluated... 
	\pgfmath@processalloperations%
	% ...and the operation pushed onto the stack.
	\pgfmath@stackpushoperator{\pgfmathgreaterthan@}%
	\pgfmath@parse@}

\def\pgfmath@parse@lessthan{%
	\pgfmath@processalloperations%
	\pgfmath@stackpushoperator{\pgfmathlessthan@}%
	\pgfmath@parse@}

\def\pgfmath@parse@equalto={%
	\pgfmath@processalloperations%
	\pgfmath@stackpushoperator{\pgfmathequalto@}%
	\pgfmath@parse@}

\def\pgfmath@parse@power{%
	% Easy, just push power onto the stack.
	\pgfmath@stackpushoperator{\pgfmathpow@}%
	\pgfmath@parse@}

\def\pgfmath@parse@radians{%
	% r is a post-fix function...
	\ifx\pgfmath@primaryoperation\pgfmath@empty%
	\else%
		\pgfmath@processoperationsuntil{\pgfmathequalto@\pgfmathlessthan@\pgfmathgreaterthan@%
			\pgfmathadd@\pgfmathsubtract@}%
	\fi%	
	\pgfmath@stackpop{\pgfmath@temp}%
	\pgfmathdeg@{\pgfmath@temp}%
	% ...so processing returns to \pgfmath@parse@operator
	\pgfmath@parse@operator}
	
\newdimen\pgfmath@dimen
\newcount\c@pgfmath@count

% \pgfmath@qparse@operand
%
% An operand can *only* be a dimension.
%
\def\pgfmath@qparse@operand{%
	\afterassignment\pgfmath@qparse@operand@%
	\pgfmath@dimen\pgfmath@token}
\def\pgfmath@qparse@operand@{%
	\edef\pgfmathresult{\pgfmath@tonumber{\pgfmath@dimen}}%
	\pgfmath@parse@operator%
}

\def\pgfmath@parse@operand{%
	\let\pgfmathresult=\pgfmath@empty%
	\let\pgfmath@mantisse=\pgfmath@empty%
	\let\pgfmath@exponent=\pgfmath@empty%
	\let\pgfmath@number=\pgfmath@empty%
	\c@pgfmath@count=1\relax%
	\expandafter\pgfmath@parse@sign\pgfmath@token}
	
\def\pgfmath@parse@sign#1{%
	% Remove multiple signs.
	\ifx#1-%
		\c@pgfmath@count=-\c@pgfmath@count%
		\let\pgfmath@parse@next=\pgfmath@parse@sign%
	\else%
		\ifx#1+%
			\let\pgfmath@parse@next=\pgfmath@parse@sign%
		\else%
			\ifnum\c@pgfmath@count>0\relax%
				\let\pgfmath@sign=\pgfmath@empty%
			\else%
				\def\pgfmath@sign{-}%
			\fi%
			\def\pgfmath@insert@token{#1}%
			\let\pgfmath@insert@after=\pgfmath@parse@postsign%
			\let\pgfmath@parse@next=\pgfmath@insert%
		\fi%
	\fi%
	\pgfmath@parse@next%
}

\def\pgfmath@parse@postsign{%
	\if\pgfmath@insert@token(% Check for the start of a group.
		\let\pgfmath@parse@next=\pgfmath@parse@startgroup%
	\else%
		\let\pgfmath@token=\pgfmath@insert@token%
		\let\pgfmath@parse@next=\pgfmath@parse@number%
	\fi%
	\pgfmath@parse@next}
	
\def\pgfmath@ifregister@dimen#1{%
	\def\pgfmath@register{#1}%
	\edef\pgfmath@register@value{\the#1}%
	\afterassignment\pgfmath@@ifregister@dimen%
	#1=0pt\relax\pgfmath@}
	
\def\pgfmath@@ifregister@dimen#1#2\pgfmath@{%
	\ifx#1p%
		\let\pgfmath@parse@next\pgfmath@secondoftwo%
	\else%
		\let\pgfmath@parse@next\pgfmath@firstoftwo%
	\fi%
	\pgfmath@register=\pgfmath@register@value\relax% Restore value.
	\pgfmath@parse@next%
}

\def\pgfmath@parse@number#1{%
	\ifx#1@% The end of the parse?
		\ifx\pgfmathresult\pgfmath@empty%
			\edef\pgfmathresult{\pgfmath@sign\pgfmath@number}%
		\fi%
		\let\pgfmath@parse@next=\pgfmath@parse@operator%
	\else%
		\ifcat#1\relax% An unexpandable control sequence?
			\ifx#1\wd%
				\let\pgfmath@boxdimen=\wd%
				\let\pgfmath@parse@next=\pgfmath@parse@box%
			\else%
				\ifx#1\ht%
					\let\pgfmath@boxdimen=\ht%
					\let\pgfmath@parse@next=\pgfmath@parse@box%
				\else%
					\ifx#1\dp%
						\let\pgfmath@boxdimen=\dp%
						\let\pgfmath@parse@next=\pgfmath@parse@box%
					\else%
						\pgfmath@ifregister@dimen#1{% A dimension or skip register?
							\ifx\pgfmath@number\pgfutil@empty%
								\edef\pgfmathresult{\pgfmath@sign\pgfmath@tonumber{#1}}%
							\else%
								\pgfmath@dimen=\pgfmath@number#1\relax%
								\edef\pgfmathresult{\pgfmath@sign\pgfmath@tonumber{\pgfmath@dimen}}%
							\fi%
							\global\pgfmathunitsdeclaredtrue% A dimension has units.
							\let\pgfmath@parse@next=\pgfmath@parse@operator%
						}%
						{% So, a count register.
							\let\pgfmath@number=\pgfmath@register@value%
							\let\pgfmathresult=\pgfmath@register@value%
							\let\pgfmath@parse@next=\pgfmath@parse@number%
						}%
					\fi%
				\fi%
			\fi%
		\else%
			\chardef\pgfmath@char=`#1\relax%
			\edef\pgfmath@char{\the\pgfmath@char}% Strange, but necessary.
			\ifnum\pgfmath@char=46\relax% A Period?
				\edef\pgfmath@number{\pgfmath@number.}%
				\let\pgfmath@parse@next=\pgfmath@parse@number%
			\else%
				\let\pgfmath@parse@next=\relax%
				\ifnum\pgfmath@char<58\relax% A digit?
					\ifnum\pgfmath@char>47\relax%
						\edef\pgfmath@number{\pgfmath@number#1}%
						\let\pgfmath@parse@next=\pgfmath@parse@number%
					\fi%
				\fi%
				\ifx\pgfmath@parse@next\relax%
					\def\pgfmath@insert@token{#1}%
					\ifnum\pgfmath@char>64\relax% From A-Z?
						\ifnum\pgfmath@char<91\relax%
							\let\pgfmath@parse@next=\pgfmath@parse@alpha%
						\else%
							\ifnum\pgfmath@char>96\relax% From a-z?
								\ifnum\pgfmath@char<123\relax%
									\let\pgfmath@parse@next=\pgfmath@parse@alpha%
								\fi%
							\fi%
						\fi%
					\fi%
					\ifx\pgfmath@parse@next\relax% Must be an operator.
						\edef\pgfmathresult{\pgfmath@sign\pgfmath@number}%
						\let\pgfmath@insert@after=\pgfmath@parse@operator%
						\let\pgfmath@parse@next=\pgfmath@insert%
					\fi%
				\fi%
			\fi%
		\fi%
	\fi%
	\pgfmath@parse@next%
}

\def\pgfmath@parse@box#1{%
	\ifx\pgfmath@number\pgfutil@empty%
		\edef\pgfmathresult{\pgfmath@sign\the\pgfmath@boxdimen#1}%
	\else%
		\pgfmath@dimen=\pgfmath@sign\pgfmath@number\pgfmath@boxdimen#1\relax%
		\edef\pgfmathresult{\pgfmath@tonumber{\pgfmath@dimen}}%
	\fi%
	\global\pgfmathunitsdeclaredtrue% a box dimension has units.
	\pgfmath@parse@operator%
}

\def\pgfmath@parse@alpha#1{%
	\ifx\pgfmath@number\pgfmath@empty% A function.
		\edef\pgfmath@insert@token{\pgfmath@insert@token#1}%
		\let\pgfmath@insert@after=\pgfmath@parsefunction%
		\let\pgfmath@parse@next\pgfmath@insert%
	\else%
		\expandafter\if\pgfmath@insert@token e%
			\if#1x% Check for ex unit...
				\def\pgfmath@unit{ex}%
				\let\pgfmath@parse@next=\pgfmath@parse@units%
			\else%
				\if#1m% ...check for em unit...
					\def\pgfmath@unit{em}%
					\let\pgfmath@parse@next=\pgfmath@parse@units%
				\else% ...it's an exponent.
					\let\pgfmath@e@token\pgfmath@insert@token%
					\def\pgfmath@insert@token{#1}%
					\let\pgfmath@insert@after=\pgfmath@parse@exponent%
					\let\pgfmath@parse@next=\pgfmath@insert%
				\fi%
			\fi%
		\else%
			\expandafter\if\pgfmath@insert@token E% The capital exponent.
				\let\pgfmath@e@token\pgfmath@insert@token%
				\def\pgfmath@insert@token{#1}%
				\let\pgfmath@insert@after=\pgfmath@parse@exponent%
				\let\pgfmath@parse@next=\pgfmath@insert%
			\else%
				\expandafter\if\pgfmath@insert@token r\relax% The postfix r function?
					\edef\pgfmathresult{\pgfmath@sign\pgfmath@number}%
					\edef\pgfmath@insert@token{\pgfmath@insert@token#1}%
					\let\pgfmath@insert@after=\pgfmath@parse@operator%
					\let\pgfmath@parse@next=\pgfmath@insert%
				\else%
					\edef\pgfmath@unit{\pgfmath@insert@token#1}%
					\edef\pgfmathresult{\pgfmath@sign\pgfmath@number}% Must be units.
					\let\pgfmath@parse@next=\pgfmath@parse@units%
				\fi%
			\fi%
		\fi%
	\fi%
	\pgfmath@parse@next%
}

\def\pgfmath@parse@exponent{%
	\let\pgfmath@mantisse=\pgfmath@number%
	\afterassignment\pgfmath@@parse@exponent% Parse exponent by assignment...
	\c@pgfmath@count=}

\def\pgfmath@@parse@exponent{% ...as it shouldn't be as big as 2^31-1
	\edef\pgfmath@exponent{\the\c@pgfmath@count}%
	\edef\pgfmathresult{\pgfmath@sign\pgfmath@number\pgfmath@e@token\the\c@pgfmath@count}%
	\pgfmath@parse@scientific}
	
\def\pgfmath@parse@units{%
	\edef\pgfmathresult{\pgfmath@sign\pgfmath@number}%
	\global\pgfmathunitsdeclaredtrue%
	\pgfmath@dimen\pgfmathresult\pgfmath@unit\relax%
	\edef\pgfmathresult{\pgfmath@tonumber{\pgfmath@dimen}}%
	\pgfmath@parse@operator%
}

\def\pgfmath@insert{\expandafter\pgfmath@insert@after\pgfmath@insert@token}%


% Process 'Scientific' notation in the form xEy
%
\def\pgfmath@parse@scientific{%
	\pgfmathscientific{\pgfmath@mantisse}{\pgfmath@exponent}% Comment this line out.
	% 
	% Here is an example of the creation of a result object. To test it,
	% comment out the first line in this macro to prevent evaluation.
	% 
	%	\let\pgfmathresultobject=\pgfmath@empty%
	%	\pgfmath@adddef@tomacro{\pgfmath@mantisse}{\pgfmathresultobject}%
	%	\pgfmath@adddef@tomacro{\pgfmath@exponent}{\pgfmathresultobject}%
	%	\pgfmath@adddef@tomacro{\pgfmathresult}{\pgfmathresultobject}%
	%	\let\pgfmathresult=\pgfmathresultobject%
	%
	\pgfmath@parse@operator}
	
\def\pgfmath@adddef@tomacro#1#2{%
	\edef\pgfmath@deftemp{\noexpand\def\noexpand#1{#1}}%
	\expandafter\expandafter\expandafter\def%
		\expandafter\expandafter\expandafter#2%
			\expandafter\expandafter\expandafter{\expandafter#2\pgfmath@deftemp}%
}



% Functions parsed (not calculated) here are:
%
% round(X)         'half-up' rounding.
% floor(X)         floor function.
% ciel(X)          ceiling function.
% abs(X)           absolute function.
%
% exp(X)           e^X (0 <= X <~= 9.7).
% ln(X)            logarithm of X.
% pow(X,Y)         X^Y,
%
% sin(X)           sine function.
% cos(X)           cosine function.
% tan(X)           tan function.
% asin(X)          arcsine of X (in radians)    -1 <= X <= 1
% acos(X)          arccosine of X (in radians)  -1 <= X <= 1
% atan(X)          arctangent of X (in radians) -1 <= X <= 1
% veclen(X,Y)      the length Z where Z^2 = X^2 + Y^2
% mod(X,Y)         X modulo Y
% max(X,Y)         the maximum of X or Y
% min(X,Y)         the minimum of X or Y
%
% NB veclen, mod, max, and min *cannot* be nested.
%
% deg(X)           converts X to degrees (X in radians)
% rad(X)           converts X to radians (X in degrees)
%
% rnd              generate pseudo-random number X (0 <= X <= 1).
% rand             generate pseudo-random number X (1 <= X <= -1).
% sqrt(X)          square root.
% 
% pi               the constant PI.
%


% Functions for compatability with calc.
%
%
\def\pgfmath@parsefunction@widthof(#1){%
	\setbox\pgfmath@box=\hbox{{\let\nullfont=\relax\pgfutil@selectfont#1}}%
	\edef\pgfmathresult{\pgfmath@tonumber{\wd\pgfmath@box}}%
	\pgfmath@parse@operator}

\def\pgfmath@parsefunction@heightof(#1){%
	\setbox\pgfmath@box=\hbox{{\let\nullfont=\relax\pgfutil@selectfont#1}}%
	\edef\pgfmathresult{\pgfmath@tonumber{\ht\pgfmath@box}}%
	\pgfmath@parse@operator}

\def\pgfmath@parsefunction@depthof(#1){%
	\setbox\pgfmath@box=\hbox{{\let\nullfont=\relax\pgfutil@selectfont#1}}%
	\edef\pgfmathresult{\pgfmath@tonumber{\dp\pgfmath@box}}%
	\pgfmath@parse@operator}


\def\pgfmath@parsefunction{%
	\def\pgfmath@parsedfunctionname{}%
	\futurelet\pgfmath@parsetoken\pgfmath@parsefunction@@}
\def\pgfmath@parsefunction@@#1{%
	\pgfmath@in@#1{()@+-*/^<>=}% A function name ends with one of these...
	\ifpgfmath@in@%
		\let\pgfmath@parsefunctionnext\pgfmath@parsefunction@end%
	\else%
		\ifx\pgfmath@parsetoken\pgfmath@sptoken% ...or a space.
			\let\pgfmath@parsefunctionnext\pgfmath@parsefunction@end%
		\else%
			\let\pgfmath@parsefunctionnext\pgfmath@parsefunction@continue%
	\fi\fi%
	\pgfmath@parsefunctionnext#1}

\def\pgfmath@parsefunction@end#1{%
	\expandafter\ifx\csname pgfmath@parsefunction@\pgfmath@parsedfunctionname\endcsname\relax%
		\pgfmath@reportunknownfunction%
		\let\pgfmath@parsefunctionnext\relax%
	\else%
		\let\pgfmath@parsefunctionnext\pgfmath@executeparsefunction@%
	\fi%
	\pgfmath@parsefunctionnext#1}

\def\pgfmath@parsefunction@continue#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\futurelet\pgfmath@parsetoken\pgfmath@parsefunction@@}
	
\def\pgfmath@executeparsefunction@{\csname pgfmath@parsefunction@\pgfmath@parsedfunctionname\endcsname}
		
		
\def\pgfmath@reportunknownfunction{%
	\pgfmath@error{Unknown function `\pgfmath@parsedfunctionname'}{}%
}

% \pgfmath@postfunction
% 
% In scanning a function e.g. sin(40), we subvert the normal parsing 
% group mechanism by messing around with \pgfmath@parse@postgroup, so 
% that after scanning ), the parser doesn't scan for an operator, but 
% returns to the macros scanning the function. 
% Here the mechanism is restored, and the value of the function is 
% stored along with the approprate sign, which was saved earlier.
%
\def\pgfmath@postfunction{%
	\let\pgfmath@parse@postgroup\pgfmath@parse@operator%
	\edef\pgfmathresult{\pgfmath@sign\pgfmathresult}%
	\pgfmath@parse@operator}
	

% \pgfmath@parsefunction@abs
%
\def\pgfmath@parsefunction@abs{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@abs@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@abs@{%	
	\expandafter\pgfmathabs@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@sqrt
%
\def\pgfmath@parsefunction@sqrt{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@sqrt@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@sqrt@{%	
	\expandafter\pgfmathsqrt@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@round
%
\def\pgfmath@parsefunction@round{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@round@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@round@{%	
	\expandafter\pgfmathround@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@floor
%
\def\pgfmath@parsefunction@floor{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@floor@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@floor@{%	
	\expandafter\pgfmathfloor@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@ceil
%
\def\pgfmath@parsefunction@ceil{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@ceil@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@ceil@{%	
	\expandafter\pgfmathceil@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@sin
%
\def\pgfmath@parsefunction@sin{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@sin@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@sin@{%	
	\expandafter\pgfmathsin@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@cos
%
\def\pgfmath@parsefunction@cos{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@cos@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@cos@{%	
	\expandafter\pgfmathcos@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@asin
%
\def\pgfmath@parsefunction@asin{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@asin@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@asin@{%	
	\expandafter\pgfmathasin@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@acos
%
\def\pgfmath@parsefunction@acos{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@acos@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@acos@{%	
	\expandafter\pgfmathacos@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction}

% \pgfmath@parsefunction@atan
%
\def\pgfmath@parsefunction@atan{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@atan@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@atan@{%	
	\expandafter\pgfmathatan@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@tan
%
\def\pgfmath@parsefunction@tan{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@tan@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@tan@{%	
	\expandafter\pgfmathtan@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@cot
%
\def\pgfmath@parsefunction@cot{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@cot@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@cot@{%	
	\expandafter\pgfmathcot@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@sec
%
\def\pgfmath@parsefunction@sec{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@sec@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@sec@{%	
	\expandafter\pgfmathsec@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@cosec
%
\def\pgfmath@parsefunction@cosec{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@cosec@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@cosec@{%	
	\expandafter\pgfmathcosec@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@rad
%
\def\pgfmath@parsefunction@rad{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@rad@%
	\pgfmath@parse@}
\def\pgfmath@parsefunction@rad@{%
	\expandafter\pgfmathrad@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction}%
	
% \pgfmath@parsefunction@rad
%
\def\pgfmath@parsefunction@deg{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@deg@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@deg@{%
	\expandafter\pgfmathdeg@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction}%
	
% \pgfmath@parsefunction@rnd
%
\def\pgfmath@parsefunction@rnd{%
	\pgfmathrnd%
	\pgfmath@postfunction}
			
% \pgfmath@parsefunction@rand
%
\def\pgfmath@parsefunction@rand{%
	\pgfmathrand%
	\pgfmath@postfunction}%
			
% \pgfmath@parsefunction@exp
%
\def\pgfmath@parsefunction@exp{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@exp@%
	\pgfmath@parse@}
\def\pgfmath@parsefunction@exp@{%	
	\expandafter\pgfmathexp@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@ln
%
\def\pgfmath@parsefunction@ln{%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@ln@%
	\expandafter\pgfmath@parse@}
\def\pgfmath@parsefunction@ln@{%	
	\expandafter\pgfmathln@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}
	
% \pgfmath@parsefunction@pi
%
\def\pgfmath@parsefunction@pi{%
	\pgfmathpi%
	\pgfmath@postfunction%
}

% \pgfmath@parsefunction@veclen
%
\def\pgfmath@parsefunction@veclen{%
	\expandafter\pgfmath@parsefunction@veclen@}
\def\pgfmath@parsefunction@veclen@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@veclen@@
	\pgfmath@parse@startgroup}
\def\pgfmath@parsefunction@veclen@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathveclen@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}

% \pgfmath@parsefunction@mod 
%
\def\pgfmath@parsefunction@mod{%
	\expandafter\pgfmath@parsefunction@mod@}
\def\pgfmath@parsefunction@mod@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@mod@@
	\pgfmath@parse@startgroup}
\def\pgfmath@parsefunction@mod@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathmod@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}

% \pgfmath@parsefunction@max
%
\def\pgfmath@parsefunction@max{%
	\expandafter\pgfmath@parsefunction@max@}
\def\pgfmath@parsefunction@max@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@max@@
	\pgfmath@parse@startgroup}
\def\pgfmath@parsefunction@max@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathmax@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}	

% \pgfmath@parsefunction@min 
%
\def\pgfmath@parsefunction@min{%
	\expandafter\pgfmath@parsefunction@min@}
\def\pgfmath@parsefunction@min@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@min@@
	\pgfmath@parse@startgroup}
\def\pgfmath@parsefunction@min@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathmin@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}
	
% \pgfmath@parsefunction@pow 
%
\def\pgfmath@parsefunction@pow{%
	\expandafter\pgfmath@parsefunction@pow@}
\def\pgfmath@parsefunction@pow@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parse@postgroup\pgfmath@parsefunction@pow@@
	\pgfmath@parse@startgroup}
\def\pgfmath@parsefunction@pow@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathpow@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}	