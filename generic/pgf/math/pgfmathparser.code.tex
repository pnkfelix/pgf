% This file parses/evaluates a decimal expression.
%
% (c) 2007 Mark Wibrow
%
% but subject to the LaTeX Project Public License, 
% (http://www.latex-project.org/lppl.txt)
%
% and the GNU Public License,
% (http://www.gnu.org/licenses/gpl.txt)

% \pgfmathparse, \pgfmathqparse
%
% Evaluates a decimal expression.
%
% #1 - the expression.
%
% returns
%
% x = the result as a dimension.
%
% E.g.
% \pgfmathparse{3pt*2cm+1.5}
% \pgfmathqparse{3pt*2cm+1.5pt}
%
% Every number in \pgfmathqparse *must*
% specify a unit.
%
\newif\ifpgfmath@quickparse

\def\pgfmathparse{%
	\pgfmath@quickparsefalse%
	\pgfmathparse@}

\def\pgfmathqparse{%
	\pgfmath@quickparsetrue%
	\pgfmathparse@}
		
\def\pgfmathparse@#1{%
	\begingroup%
    % Reinstall correct font, so that dimensions like 1em are correct
	 \pgfutil@selectfont%
		\edef\pgfmath@temp{#1}%
		\pgfmath@resetparsingparameters%
		\global\pgfmath@unitsdeclaredfalse%
		\ifpgfmath@quickparse%
			\let\pgfmath@parseoperand\pgfmath@quickparseoperand%
		\else%
			\let\pgfmath@parseoperand\pgfmath@parseoperand%
		\fi%
		\let\pgfmath@parsepostgroup\pgfmath@parseoperator%
		\expandafter\pgfmath@parse@\pgfmath@temp @@@@@@@@@@@\pgfmath@empty}


% \pgfmath@resetparsingparameters
%
% Reset parsing parameters at begining of groups.
%
\def\pgfmath@resetparsingparameters{%
	\let\pgfmath@a\pgfmath@empty%
	\let\pgfmath@b\pgfmath@empty%
	\let\pgfmath@c\pgfmath@empty%
	\let\pgfmath@d\pgfmath@empty%
	\let\pgfmath@primaryoperation\pgfmath@empty%
	\let\pgfmath@secondaryoperation\pgfmath@empty%
	\let\pgfmath@tertiaryoperation\pgfmath@empty%
}

% \pgfmath@parse@
%
% Start parsing. Expect one of
% 1) the end of the parse
% 2) the start of a group
% 3) a (possible) operand.
%
\def\pgfmath@parse@#1{%
	\def\pgfmath@token{}%
	\ifx#1@%
		\let\pgfmath@parsenext\pgfmath@endparse%
	\else%
		\ifx#1(%
			\let\pgfmath@parsenext\pgfmath@startparsegroup%
		\else%
			\edef\pgfmath@token{#1}%
			\let\pgfmath@parsenext\pgfmath@parseoperand%
	\fi\fi%
	\pgfmath@parsenext%
}

% If no TeX units are declared *at any point* in the parse
% the result is scaled by \pgfmathresultunitscale.
\newif\ifpgfmath@unitsdeclared
\def\pgfmathsetresultunitscale#1{\def\pgfmathresultunitscale{#1}}
\def\pgfmathresultunitscale{1}

% \pgfmath@endparse
%
% Everything stops here.
%
\def\pgfmath@endparse#1\pgfmath@empty{%
	\pgfmath@processalloperations%
		\begingroup%
			\ifpgfmath@unitsdeclared%
				\pgfmath@x1pt\relax%
			\else%
				\afterassignment\pgfmath@gobbletilpgfmath@
				\pgfmath@x\pgfmathresultunitscale pt\relax\pgfmath@%
			\fi%
			\pgfmath@x=\pgfmath@a\pgfmath@x%
			\pgfmath@returnone\pgfmath@x%
		\endgroup%
		\pgfmath@smuggleone{\pgfmathresult}%
	\endgroup%
}

% \pgfmath@startparsegroup
%
% When opening ( is scanned start a new group.
%
\def\pgfmath@startparsegroup{%
	\begingroup%
		\pgfmath@resetparsingparameters
		\pgfmath@parse@}

% \pgfmath@startparsegroup
%
% When closing ) is scanned, processes all waiting
% operations (within the group) and close the group.
%
\def\pgfmath@endparsegroup{%
		\pgfmath@processalloperations%
		\pgfmath@x=\pgfmathresult pt\relax%
		\pgfmath@returnone\pgfmath@x%
	\endgroup%
	\pgfmath@parsepostgroup%
}

% \pgfmath@parseoperator
%
% An operator is expected here. 
% Or the end of the parse or parse group.
% 
\def\pgfmath@parseoperator#1{%
	\def\pgfmath@token{}%
	\pgfmath@assignnumber%
	\ifx#1@%
		\let\pgfmath@parsenext\pgfmath@endparse%
	\else%
		\ifx#1+%
			\let\pgfmath@parsenext\pgfmath@parseadd%
		\else%
			\ifx#1-%
				\let\pgfmath@parsenext\pgfmath@parsesubtract%
			\else%
				\ifx#1*%
					\let\pgfmath@parsenext\pgfmath@parsemultiply%
				\else%
					\ifx#1/%
						\let\pgfmath@parsenext\pgfmath@parsedivide%
					\else
						\ifx#1)%
							\let\pgfmath@parsenext\pgfmath@endparsegroup%
						\else%
							\ifx#1r%
								\let\pgfmath@parsenext\pgfmath@parseradians%
							\else%
								\ifx#1>%
									\let\pgfmath@parsenext\pgfmath@parsegreaterthan%
								\else%
									\ifx#1<%
										\let\pgfmath@parsenext\pgfmath@parselessthan%
									\else%
										\if#1=%
											\let\pgfmath@parsenext\pgfmath@parseequalto%
										\else%
											\if#1^%
												\let\pgfmath@parsenext\pgfmath@parsepower%
											\else%
												\pgfmath@error{Unknown operator `#1'}%
												\let\pgfmath@parsenext\relax%
	\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi%
	\pgfmath@parsenext%
}

% \pgfmath@assignnumber
%
% Scanned or computed numbers are stored here.
%
\def\pgfmath@assignnumber{%
	\ifx\pgfmath@a\pgfmath@empty%
		\edef\pgfmath@a{\pgfmathresult}%
	\else%
		\edef\pgfmath@b{\pgfmathresult}%
	\fi%
}		

% \pgfmath@processalloperations
%
% If various operations are not empty, perform them.
% \pgfmath@primaryoperation      - used for any current operation.
% \pgfmath@secondaryoperation    - used to store + - if * / encountered
% \pgfmath@tertiaryoperation     - used to store = > <
%
\def\pgfmath@processalloperations{%
	\pgfmath@processprimaryoperation%
	\pgfmath@processsecondaryoperation%
	\pgfmath@processtertiaryoperation}

\def\pgfmath@processprimaryoperation{%
	\ifx\pgfmath@primaryoperation\pgfmath@empty%
	\else%
		\pgfmath@primaryoperation{\pgfmath@a}{\pgfmath@b}%
		\edef\pgfmath@a{\pgfmathresult}%
	\fi%
	\let\pgfmath@primaryoperation\pgfmath@empty%
	\let\pgfmath@b\pgfmath@empty%
}

\def\pgfmath@processsecondaryoperation{%
	\ifx\pgfmath@secondaryoperation\pgfmath@empty%
	\else%
		\pgfmath@secondaryoperation{\pgfmath@c}{\pgfmath@a}%
		\edef\pgfmath@a{\pgfmathresult}%
	\fi%
	\let\pgfmath@secondaryoperation\pgfmath@empty%
	\let\pgfmath@b\pgfmath@empty%
	\let\pgfmath@c\pgfmath@empty%
}
	
\def\pgfmath@processtertiaryoperation{%
	\ifx\pgfmath@tertiaryoperation\pgfmath@empty%
	\else%
		\pgfmath@tertiaryoperation{\pgfmath@d}{\pgfmath@a}%
		\edef\pgfmath@a{\pgfmathresult}%
	\fi
	\let\pgfmath@tertiaryoperation\pgfmath@empty%
	\let\pgfmath@b\pgfmath@empty%
	\let\pgfmath@c\pgfmath@empty%
	\let\pgfmath@d\pgfmath@empty%
}%

% OK. Now the operators are parsed.
% These correspond to the + - / * ^ < > = mod and r operators 
%
\def\pgfmath@parseadd{%
	% If no operator has been assigned (i.e. + is the first operator scanned),
	% do nothing, except make addition the primary operation.
	\ifx\pgfmath@primaryoperation\pgfmath@empty
	\else%
		% Otherwise process the primary and the secondary operations.
		%
		% Consider the epxression A-B*C+D.
		% At this point + has just been parsed, so the primary operation is *,
		% and the secondary operation is - (it was saved after * was parsed).
		\pgfmath@processprimaryoperation%
		\pgfmath@processsecondaryoperation%
	\fi%
	\let\pgfmath@primaryoperation\pgfmathadd@%
	\pgfmath@parse@}

\def\pgfmath@parsesubtract{% Works like addition.
	\ifx\pgfmath@primaryoperation\pgfmath@empty%
	\else%
		\pgfmath@processprimaryoperation%
		\pgfmath@processsecondaryoperation%
	\fi%
	\let\pgfmath@primaryoperation\pgfmathsubtract@%
	\pgfmath@parse@}

\def\pgfmath@parsemultiply{%
	% If no operator has been assigned (i.e. * is the first operator scanned),
	% do nothing, except make multiplication the primary operation.
	\ifx\pgfmath@primaryoperation\pgfmath@empty
	\else%
		% Slighty tricker than addition/subtraction...
		% Consder X\Y*Z, when * has been scanned. 
		% The primary operation is \, so this operation can be processed, 
		% and * made the new primary opertion.
		\ifx\pgfmath@primaryoperation\pgfmathmultiply@
			\pgfmath@processprimaryoperation%
		\else
			\ifx\pgfmath@primaryoperation\pgfmathdivide@%
				\pgfmath@processprimaryoperation%
			\else%
				\ifx\pgfmath@primaryoperation\pgfmathpower@%
					\pgfmath@processprimaryoperation%
				\else%
					% Consder X+Y*Z, when * has been scanned. 
					% The addition must take place *after* the multiplication. 
					% So + (the current primary operation), is saved as the secondary  
					% operation, and X is saved. * becomes the new primary operation.
					\let\pgfmath@secondaryoperation\pgfmath@primaryoperation%
					\edef\pgfmath@c{\pgfmath@a}%
					\edef\pgfmath@a{\pgfmath@b}%
					\let\pgfmath@b\pgfmath@empty%	
	\fi\fi\fi\fi%
	\let\pgfmath@primaryoperation\pgfmathmultiply@%
	\pgfmath@parse@}

\def\pgfmath@parsedivide{% Works like multiplication.
	\ifx\pgfmath@primaryoperation\pgfmath@empty
	\else%
		\ifx\pgfmath@primaryoperation\pgfmathmultiply@
			\pgfmath@processprimaryoperation%
		\else
			\ifx\pgfmath@primaryoperation\pgfmathdivide@%
				\pgfmath@processprimaryoperation%
			\else%
				\ifx\pgfmath@primaryoperation\pgfmathpower@%
					\pgfmath@processprimaryoperation%
				\else%
					\let\pgfmath@secondaryoperation\pgfmath@primaryoperation%
					\edef\pgfmath@c{\pgfmath@a}%
					\edef\pgfmath@a{\pgfmath@b}%
					\let\pgfmath@b\pgfmath@empty%	
	\fi\fi\fi\fi%
	\let\pgfmath@primaryoperation\pgfmathdivide@%
	\pgfmath@parse@}

\def\pgfmath@parsegreaterthan{%
	% On scanning an equality/inequality operator everything up to
	% (but not including) the operator is evaluated... 
	\ifx\pgfmath@primaryoperation\pgfmath@empty%
		\pgfmath@processalloperations%
	\fi%
	% ...now the LHS of the inequality must be saved...
	\edef\pgfmath@temp{\pgfmath@a}%
	% ...all parsing parameters are reset...
	\pgfmath@resetparsingparameters%
	\edef\pgfmath@d{\pgfmath@temp}% ...but one parameter reinserted.
	% ....and the inequality defined as the tertiary opertation.
	\let\pgfmath@tertiaryoperation\pgfmathgreaterthan@%
	\pgfmath@parse@}
	
\def\pgfmath@parselessthan{% Similar to greater than.
	\ifx\pgfmath@primaryoperation\pgfmath@empty%
		\pgfmath@processalloperations%
	\fi%
	\edef\pgfmath@temp{\pgfmath@a}%
	\pgfmath@resetparsingparameters%
	\edef\pgfmath@d{\pgfmath@temp}%
	\let\pgfmath@tertiaryoperation\pgfmathlessthan@%
	\pgfmath@parse@}
	
\def\pgfmath@parseequalto{% Similar to greater than.
	\ifx\pgfmath@primaryoperation\pgfmath@empty%
		\pgfmath@processalloperations%
	\fi%
	\edef\pgfmath@temp{\pgfmath@a}%
	\pgfmath@resetparsingparameters%
	\edef\pgfmath@d{\pgfmath@temp}%
	\let\pgfmath@tertiaryoperation\pgfmathequalto@%
	\pgfmath@parse@}

			
\def\pgfmath@parsepower{%
	\ifx\pgfmath@primaryoperation\pgfmath@empty%
	\else%
		\let\pgfmath@secondaryoperation\pgfmath@primaryoperation%
		\edef\pgfmath@c{\pgfmath@a}%
		\edef\pgfmath@a{\pgfmath@b}%
		\let\pgfmath@b\pgfmath@empty%		
	\fi%
	\let\pgfmath@primaryoperation\pgfmathpower@%
	\pgfmath@parse@}
	
\def\pgfmath@parseradians{%
	\ifx\pgfmath@primaryoperation\pgfmath@empty%
		\pgfmathradians@{\pgfmath@a}%
		\let\pgfmath@a\pgfmath@empty%
	\else%
		\ifx\pgfmath@primaryoperation\pgfmathmultiply@%
			\pgfmath@processprimaryoperation%
			\pgfmathradians@{\pgfmath@a}%
			\let\pgfmath@a\pgfmath@empty%
		\else%
			\ifx\pgfmath@primaryoperation\pgfmathdivide@%
				\pgfmath@processprimaryoperation%
				\pgfmathradians@{\pgfmath@a}%
				\let\pgfmath@a\pgfmath@empty
			\else%
				\pgfmathradians@{\pgfmath@b}%
	\fi\fi\fi%	
	% Notice unlike the other operators, we go to \pgfmath@parseoperator,
	% This is because, r is really a post-fix function.
	\pgfmath@parseoperator}


\newcount\c@pgfmath@parsecounta
\newcount\c@pgfmath@parsecountb
\newdimen\pgfmath@parsex


% \pgfmath@quickparseoperand
%
% An operand can *only* be a dimension.
%
\def\pgfmath@quickparseoperand{%
	\afterassignment\pgfmath@quickparseoperand@%
	\pgfmath@parsex\pgfmath@token}
\def\pgfmath@quickparseoperand@{%
	\edef\pgfmathresult{\pgfmath@tonumber{\pgfmath@parsex}}
	\pgfmath@parseoperator%
}
	
% \pgfmath@parseoperand
%
% An operand can be an ASCII number (with or without dimensions, with
% or without a decimal point), a TeX register (count, dimen or skip,
% which may have expanded with \the), or a function e.g. sin(X).
%
% It is assumed that after \edef-ing, the only unexpanded tokens are registers. 
%
\def\pgfmath@parseoperand{%
	\def\pgfmath@sign{}%
	\expandafter\pgfmath@parseoperandsign\pgfmath@token}
\def\pgfmath@parseoperandsign#1{%
	\pgfmath@in@#1{-+}% 
	\ifpgfmath@in@
		% I suppose there are (silly) people who might complain if
		% they can't say 2---5, or 3+-----7. Just for them...
		\edef\pgfmath@sign{\pgfmath@sign#1}%
		\expandafter\pgfmath@parseoperandsign%
	\else%
		\expandafter\pgfmath@parsenumberorfunction\expandafter#1%
	\fi%
}


\newif\ifpgfmath@dimen@

\def\pgfmath@ifregisterdimen@#1\pgfmath@{%
	\pgfmath@in@{p}{#1}%
	\ifpgfmath@in@%
		\pgfmath@dimen@true%
	\else%
		\pgfmath@dimen@false%
	\fi} 	
				
\def\pgfmath@parsenumberorfunction#1{%	
	\expandafter\ifcat#1\relax%
		% So, a TeX register.
		\afterassignment\pgfmath@ifregisterdimen@%
		\pgfmath@parsex\pgfmath@sign#1pt\relax\pgfmath@%
		\ifpgfmath@dimen@% 
			% A dimention! So stop scanning operand here.
			\edef\pgfmathresult{\pgfmath@tonumber{\pgfmath@parsex}}%
                        \global\pgfmath@unitsdeclaredtrue% a dimension has units
			\def\pgfmath@temp{}%
			\let\pgfmath@parsenext\pgfmath@parseoperator%
		\else%
			% A count! Expand it, but carry on as usual as it might
			% be immediately followed by a dimension.
			\ifdim\pgfmath@parsex<0pt\relax%
				\edef\pgfmath@sign{\pgfmath@sign-}%
				\pgfmath@parsex-\pgfmath@parsex%
			\fi%
			\edef\pgfmath@temp{\pgfmath@tonumber{\pgfmath@parsex}}%
			\let\pgfmath@parsenext\pgfmath@parsenumberorfunction@%
		\fi%
	\else%
		% Could be a number or a function...?
		\edef\pgfmath@temp{#1}%
		\let\pgfmath@parsenext\pgfmath@parsenumberorfunction@%
	\fi%
	\expandafter\pgfmath@parsenext\pgfmath@temp%
}%

\def\pgfmath@parsenumberorfunction@#1{%
	\pgfmath@in@{#1}{.0123456789}%
	\ifpgfmath@in@%
		\let\pgfmath@parsenext\pgfmath@parsenumber%
	\else%
		\let\pgfmath@parsenext\pgfmath@parsefunction%
	\fi%
	\pgfmath@parsenext#1%
}%

\def\pgfmath@parsenumber{% 
	% Consider the number 3.14159
	% 3 is parsed by assignment to a, then '.' is absorbed and 14159
	% parsed by assignement to b (actually b=114159, see below). 
	\afterassignment\pgfmath@parsedecimalpoint%
	\c@pgfmath@parsecounta0}

\def\pgfmath@parsedecimalpoint#1{%
	\ifx#1.% Is there a decimal point? If not, see if there are any units.
		\let\pgfmath@parsenext\pgfmath@parsemantissa%
	\else%
		\c@pgfmath@parsecountb10\relax% The first digit of b is gobbled (see below). 
		\let\pgfmath@parsenext\pgfmath@parseunits%
	\fi%
	\pgfmath@parsenext#1}



% We would like to assign the following number (which is the mantisse)
% to a number. However, for a very long mantisse as in 3.141592653589793238462643
% this will fail since the number becomes too large.
%
% Because of this, we have to do some ``magic'': We scan 9 tokens and
% then do an assignment with a guard after 9 tokens so that the
% assigment cannot fail.
%
\def\pgfmath@parsemantissa.#1#2#3#4#5#6#7#8#9{%
  \afterassignment\pgfmath@checkforguard%    
  % Consider the number: 2.005
  % 2 is assigned to a, but b will be assigned 5, which is *not right*. 
  % So using 1 here hereresults in  b=1005. The first digit is then  
  % gobbled later, when expanded with \the.
  \c@pgfmath@parsecountb1#1#2#3#4#5#6#7#8#9\relax}%

\def\pgfmath@checkforguard{%
  \pgfutil@ifnextchar\relax%
  {%
    % Ok, this is a looong mantisse. Start gobbling all following
    % numbers
    \pgfmath@gobblemantisse%
  }%
  {%
    \pgfmath@removeguard%
  }%
}

\def\pgfmath@gobblemantisse\relax#1#2#3#4#5#6#7#8#9{%
  \afterassignment\pgfmath@checkforguard%
  \c@pgfmath@countc#1#2#3#4#5#6#7#8#9\relax% these digits are ignored
}

\def\pgfmath@removeguard#1\relax{\pgfmath@parseunits#1}



 
\def\pgfmath@parseunits#1{%
	% Here the extra first digit in b is gobbled. 
	% Interestingly, TeX allows <dimen>=12.pt (which *I* think it shouldn't)
	\edef\pgfmath@resulttemp{%
		\pgfmath@sign\the\c@pgfmath@parsecounta.\expandafter\pgfmath@gobbleone\the\c@pgfmath@parsecountb}%
	% Now check if #1 is actually a register.
	\ifcat#1\relax%
		\afterassignment\pgfmath@ifregisterdimen@%
		\pgfmath@parsex#1pt\relax\pgfmath@%
		\pgfmath@parsex\pgfmath@resulttemp\pgfmath@parsex%
		\ifpgfmath@dimen@% If it's a dimen stop scanning operand here.
                        \global\pgfmath@unitsdeclaredtrue% a dimension has units
			\edef\pgfmathresult{\pgfmath@tonumber{\pgfmath@parsex}}%
			\let\pgfmath@parsenext\pgfmath@parseoperator%
		\else
			\edef\pgfmath@resulttemp{\pgfmath@tonumber{\pgfmath@parsex}}%
			\let\pgfmath@parsenext\pgfmath@parseunits@%
		\fi%
		\expandafter\pgfmath@parsenext%
	\else%
		\expandafter\pgfmath@parseunits@\expandafter#1%
	\fi}

\def\pgfmath@parseunits@#1#2{%
	% Check if #1 is an operator, or the character `@' indicating the end of the parse.
	\pgfmath@in@#1{@+-*/^r<>=()}%
	\ifpgfmath@in@%
		\edef\pgfmath@tokens{#1#2}%
		\edef\pgfmathresult{\pgfmath@resulttemp}%
		\let\pgfmath@parsenext\pgfmath@parseoperator%
	\else%
		% Anything else *should* be a TeX unit.
		\global\pgfmath@unitsdeclaredtrue%
		\pgfmath@parsex\pgfmath@resulttemp#1#2\relax%
		\edef\pgfmathresult{\pgfmath@tonumber{\pgfmath@parsex}}%
		\edef\pgfmath@tokens{}%
		\let\pgfmath@parsenext\pgfmath@parseoperator%
	\fi%
	\expandafter\pgfmath@parsenext\pgfmath@tokens%
}


% OK. Now the fun stuff. We parse functions here. Note that 
% *no* calulations are done in the following macros. All the
% mathematics is done in pgfmathoperations.code and friends. 
%
% Functions dealt with here are:
%
% round(X)         'half-up' rounding.
% floor(X)         floor function.
% ciel(X)          ceiling function.
% abs(X)           absolute function.
%
% exp(X)           e^X (0 <= X <~= 9.7).
%
% sin(X)           sine function.
% cos(X)           cosine function.
% tan(X)           tan function.
% asin(X)          arcsine of X (in radians)    -1 <= X <= 1
% acos(X)          arccosine of X (in radians)  -1 <= X <= 1
% atan(X)          arctangent of X (in radians) -1 <= X <= 1
% veclen(X,Y)      the length Z where Z^2 = X^2 + Y^2
% mod(X,Y)         X modulo Y
% max(X,Y)         the maximum of X or Y
% min(X,Y)         the minimum of X or Y
%
% NB veclen, mod, max, and min *cannot* be nested.
%
% rnd              generate pseudo-random number X (0 <= X <= 1).
% rand             generate pseudo-random number X (1 <= X <= -1).
% sqrt(X)          square root.
% 
% pi               the constant PI.

\def\pgfmath@parsefunction#1{%
	\def\pgfmath@parsedfunctionname{#1}%
	\ifx#1a%
		\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@a%
	\else%
		\ifx#1c%
			\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@c%
		\else%
			\ifx#1e%
				\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@e%
			\else%
				\ifx#1f%
					\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@f%
				\else%
					\ifx#1m%
						\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@m%
					\else%
						\ifx#1p%
							\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@p%
						\else%
							\ifx#1r%
								\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@r%
							\else%
								\ifx#1s%
									\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@s%
								\else%
									\ifx#1t%
										\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@t%
									\else%
										\ifx#1v%
											\let\pgfmath@parsefunctionnext\pgfmath@functionstartswith@v%
										\else
											\pgfmath@reportunknownfunction%
											\let\pgfmath@parsefunctionnext\relax%
	\fi\fi\fi\fi\fi\fi\fi\fi\fi\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@reportunknownfunction{%
	\pgfmath@error{Unknown function `\pgfmath@parsedfunctionname'}{}%
}

% \pgfmath@postfunction
% 
% In scanning a function e.g. sin(40), we subvert the normal parsing 
% group mechanism by messing around with \pgfmath@parsepostgroup, so 
% that after scanning ), the parser doesn't scan for an operator, but 
% returns to the macros scanning the function. 
% Here the mechanism is restored, and the value of the function is 
% stored along with the approprate sign, which was saved earlier.
%
\def\pgfmath@postfunction{%
	\let\pgfmath@parsepostgroup\pgfmath@parseoperator%
	\edef\pgfmathresult{\pgfmath@sign\pgfmathresult}%
	\pgfmath@parseoperator}
	
\def\pgfmath@functionstartswith@a#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1b%
		\let\pgfmath@parsefunctionnext\pgfmath@parseabs%
	\else%
		\ifx#1c%
			\let\pgfmath@parsefunctionnext\pgfmath@parseacos%
		\else%
			\ifx#1s%
				\let\pgfmath@parsefunctionnext\pgfmath@parseasin%
			\else%
				\ifx#1t%
					\let\pgfmath@parsefunctionnext\pgfmath@parseatan%
				\else
					\pgfmath@reportunknownfunction%
					\let\pgfmath@parsefunctionnext\relax%
	\fi\fi\fi\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@c#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1e%
		\let\pgfmath@parsefunctionnext\pgfmath@parseceil%
	\else%
		\ifx#1o%
			\let\pgfmath@parsefunctionnext\pgfmath@parsecos%
		\else%
			\pgfmath@reportunknownfunction%
			\let\pgfmath@parsefunctionnext\relax%
	\fi\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@e#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1x%
		\let\pgfmath@parsefunctionnext\pgfmath@parseexp%
	\else%
		\pgfmath@reportunknownfunction%
		\let\pgfmath@parsefunctionnext\relax%
	\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@f#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1l%
		\let\pgfmath@parsefunctionnext\pgfmath@parsefloor%
	\else%
		\pgfmath@reportunknownfunction%
		\let\pgfmath@parsefunctionnext\relax%
	\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@m#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1a%
		\let\pgfmath@parsefunctionnext\pgfmath@parsemax%
	\else%
		\ifx#1i%
			\let\pgfmath@parsefunctionnext\pgfmath@parsemin%
		\else%
			\ifx#1o%
				\let\pgfmath@parsefunctionnext\pgfmath@parsemod%
			\else%
				\pgfmath@reportunknownfunction%
				\let\pgfmath@parsefunctionnext\relax%
	\fi\fi\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@p#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1i%
		\let\pgfmath@parsefunctionnext\pgfmath@parsepi%
	\else%
		\pgfmath@reportunknownfunction%
		\let\pgfmath@parsefunctionnext\relax%
	\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@r#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1a%
		\let\pgfmath@parsefunctionnext\pgfmath@parserand%
	\else%
		\ifx#1n%
			\let\pgfmath@parsefunctionnext\pgfmath@parsernd%
		\else%
			\ifx#1o%
				\let\pgfmath@parsefunctionnext\pgfmath@parseround%
			\else%
				\pgfmath@reportunknownfunction%
				\let\pgfmath@parsefunctionnext\relax%
	\fi\fi\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@s#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1i%
		\let\pgfmath@parsefunctionnext\pgfmath@parsesin%
	\else%
		\ifx#1q%
			\let\pgfmath@parsefunctionnext\pgfmath@parsesqrt%
		\else%
			\pgfmath@reportunknownfunction%
			\let\pgfmath@parsefunctionnext\relax%
	\fi\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@t#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1a%
		\let\pgfmath@parsefunctionnext\pgfmath@parsetan%
	\else%
			\pgfmath@reportunknownfunction%
			\let\pgfmath@parsefunctionnext\relax%
	\fi%
	\pgfmath@parsefunctionnext%
}

\def\pgfmath@functionstartswith@v#1{%
	\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
	\ifx#1e%
		\let\pgfmath@parsefunctionnext\pgfmath@parseveclen%
	\else%
			\pgfmath@reportunknownfunction%
			\let\pgfmath@parsefunctionnext\relax%
	\fi%
	\pgfmath@parsefunctionnext%
}

% \pgfmath@parseabs
%
\def\pgfmath@parseabs#1{%
	\pgfmath@in@{#1}{s}%
	\ifpgfmath@in@%
		% The normal parsing mechansims is subverted here:
		\let\pgfmath@parsepostgroup\pgfmath@parseabs@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parseabs@{%	
	\expandafter\pgfmathabs@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsesqrt
%
\def\pgfmath@parsesqrt#1#2{%
	\pgfmath@in@{#1#2}{rt}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parsesqrt@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1#2}%
		\expandafer\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parsesqrt@{%	
	\expandafter\pgfmathsqrt@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parseround
%
\def\pgfmath@parseround#1#2#3{%
	\pgfmath@in@{#1#2#3}{und}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parseround@%
		\expandafter\pgfmath@parse@%
	\else%		
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1#2#3}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parseround@{%	
	\expandafter\pgfmathround@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsefloor
%
\def\pgfmath@parsefloor#1#2#3{%
	\pgfmath@in@{#1#2#3}{oor}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parsefloor@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1#2#3}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parsefloor@{%	
	\expandafter\pgfmathfloor@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parseceil
%
\def\pgfmath@parseceil#1#2{%
	\pgfmath@in@{#1#2}{il}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parseceil@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1#2}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parseceil@{%	
	\expandafter\pgfmathceil@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsesin
%
\def\pgfmath@parsesin#1{%
	\pgfmath@in@{#1}{n}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parsesin@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parsesin@{%	
	\expandafter\pgfmathsin@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsecos
%
\def\pgfmath@parsecos#1{%
	\pgfmath@in@{#1}{s}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parsecos@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parsecos@{%	
	\expandafter\pgfmathcos@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parseasin
%
\def\pgfmath@parseasin#1#2{%
	\pgfmath@in@{#1#2}{in}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parseasin@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1#2}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parseasin@{%	
	\expandafter\pgfmathasin@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parseacos
%
\def\pgfmath@parseacos#1#2{%
	\pgfmath@in@{#1#2}{os}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parseacos@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1#2}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parseacos@{%	
	\expandafter\pgfmathacos@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parseatan
%
\def\pgfmath@parseatan#1#2{%
	\pgfmath@in@{#1#2}{an}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parseatan@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1#2}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parseatan@{%	
	\expandafter\pgfmathatan@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsetan
%
\def\pgfmath@parsetan#1{%
	\pgfmath@in@{#1}{n}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parsetan@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parsetan@{%	
	\expandafter\pgfmathtan@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsernd
%
\def\pgfmath@parsernd#1{%
	\pgfmath@in@{#1}{d}%
	\ifpgfmath@in@%
		\expandafter\pgfmathrnd%
		\expandafter\pgfmath@postfunction%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
			
% \pgfmath@parserand
%
\def\pgfmath@parserand#1#2{%
	\pgfmath@in@{#1}{nd}%
	\ifpgfmath@in@%
		\expandafter\pgfmathrand%
		\expandafter\pgfmath@postfunction%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}%
			
% \pgfmath@parseexp
%
\def\pgfmath@parseexp#1{%
	\pgfmath@in@{#1}{p}%
	\ifpgfmath@in@%
		\let\pgfmath@parsepostgroup\pgfmath@parseexp@%
		\expandafter\pgfmath@parse@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parseexp@{%	
	\expandafter\pgfmathexp@\expandafter{\pgfmathresult}%
	\pgfmath@postfunction%
}

% \pgfmath@parsepi
%
\def\pgfmath@parsepi{%
	\pgfmathpi%
	\pgfmath@postfunction%
}


% \pgfmath@parseveclen
%
\def\pgfmath@parseveclen#1#2#3#4{%
	\pgfmath@in@{#1#2#3#4}{clen}%
	\ifpgfmath@in@%
		\expandafter\pgfmath@parseveclen@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parseveclen@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parsepostgroup\pgfmath@parseveclen@@
	\pgfmath@startparsegroup}
\def\pgfmath@parseveclen@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathveclen@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}


\def\pgfmath@parsemod#1{%
	\pgfmath@in@{#1}{d}%
	\ifpgfmath@in@%
		\expandafter\pgfmath@parsemod@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parsemod@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parsepostgroup\pgfmath@parsemod@@
	\pgfmath@startparsegroup}
\def\pgfmath@parsemod@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathmod@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}
	
\def\pgfmath@parsemax#1{%
	\pgfmath@in@{#1}{x}%
	\ifpgfmath@in@%
		\expandafter\pgfmath@parsemax@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parsemax@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parsepostgroup\pgfmath@parsemax@@
	\pgfmath@startparsegroup}
\def\pgfmath@parsemax@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathmax@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}	
	
\def\pgfmath@parsemin#1{%
	\pgfmath@in@{#1}{n}%
	\ifpgfmath@in@%
		\expandafter\pgfmath@parsemin@%
	\else%
		\edef\pgfmath@parsedfunctionname{\pgfmath@parsedfunctionname#1}%
		\expandafter\pgfmath@reportunknownfunction%
	\fi}
\def\pgfmath@parsemin@(#1,{%
	\pgfmathparse@{#1}\edef\pgfmath@firstoperand{\pgfmathresult}%
	\let\pgfmath@parsepostgroup\pgfmath@parsemin@@
	\pgfmath@startparsegroup}
\def\pgfmath@parsemin@@{%
	\edef\pgfmath@secondoperand{\pgfmathresult}%
	\pgfmathmin@{\pgfmath@firstoperand}{\pgfmath@secondoperand}%
	\pgfmath@postfunction}