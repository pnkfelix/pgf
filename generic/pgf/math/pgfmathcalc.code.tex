% Copyright 2007 by Mark Wibrow
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

% This file loads all the parsing, functions and operator stuff
%
% Version 0.0 08/03/2007

\input pgfmathutil.code.tex
\input pgfmathparser.code.tex
\input pgfmathoperations.code.tex
\input pgfmathbase.code.tex


% \pgfmathsetlength, \pgfmathaddtolength
%
% #1 = dimension register
% #2 = expression
%
% Description:
%
% These functions work similar to \setlength and \addtolength. Only,
% they allow #2 to contain an expression, which is evaluated before
% assignment. Furthermore, the font is setup before the assignment is
% done, so that dimensions like 1em are evaluated correctly.
%
% If #2 starts with "+", then a simple assignment is done (but the
% font is still setup). This is orders of magnitude faster than a
% parsed assignment.

\newdimen\mydim
\def\pgfmathsetlength#1#2{%
  \expandafter\pgfmath@onquick#2\pgfmath@%
 {%
 	 % Ok, quick version:
    #1#2\relax%
  }%
  {%
   \pgfmathparse{#2}#1\pgfmathresult pt\relax%
}%
}
\def\pgfmathaddtolength#1#2{%
	 \expandafter\pgfmath@onquick#2\pgfmath@%
  {%
    % Ok, quick version:
    \advance#1by#2\relax%
  }%
  {\pgfmathparse{#2}\advance#1\pgfmathresult pt\relax}%
}

% Not really needed and does not work in plain TeX:
%\def\pgfmathnewcounter#1{%
%	\expandafter\let\expandafter\pgfmath@register\csname c@#1\endcsname%
%	\expandafter\ifx\pgfmath@register\relax%
%    	\expandafter\newcount\csname c@#1\endcsname%
%    	\csname c@#1\endcsname0\relax%
%		\expandafter\def\csname the#1\endcsname{\expandafter\the\csname c@#1\endcsname}%
%	\else% Do nothing.
%   \fi}%
   
% \pgfmathsetcounter, \pgfmathaddtocounter
%
% Results of parsing are truncated.
%
\def\pgfmathsetcounter#1#2{%
  \expandafter\pgfmath@onquick#2\pgfmath@%
  {%
    \csname c@#1\endcsname=#2\relax%
  }%
  {%
    \pgfmath@ifundefined{c@#1}{\pgfmath@error{No counter named '#1' is known}{}}{%
      \pgfmathparse{#2}%
      \afterassignment\pgfmath@gobbletilpgfmath@%
      \csname c@#1\endcsname\pgfmathresult\relax\pgfmath@%
    }%
  }%
}

\def\pgfmathaddtocounter#1#2{%
  \expandafter\pgfmath@onquick#2\pgfmath@%
  {%
    \advance\csname c@#1\endcsname by#2\relax%
  }%
  {%
    \pgfmath@ifundefined{c@#1}{\pgfmath@error{No counter named '#1' is known}{}}{%
      \edef\pgfmath@addtocountertemp{\expandafter\the\csname c@#1\endcsname}%
      \pgfmathparse{#2}%
      \afterassignment\pgfmath@gobbletilpgfmath@%
      \csname c@#1\endcsname\pgfmathresult\relax\pgfmath@%
      \expandafter\advance\csname c@#1\endcsname\pgfmath@addtocountertemp%
    }%
  }%
}

% \pgfmathsetcount, \pgfmathaddtocount
%
% Results of parsing are truncated.
%
\def\pgfmathsetcount#1#2{%
  \expandafter\pgfmath@onquick#2\pgfmath@%
  {%
    #1#2\relax%
  }%
  {%
    \pgfmathparse{#2}%
    \afterassignment\pgfmath@gobbletilpgfmath@%
    #1\pgfmathresult\relax\pgfmath@%
  }%
}

\def\pgfmathaddtocount#1#2{%
  \expandafter\pgfmath@onquick#2\pgfmath@%
  {%
    \advance#1 by#2\relax%
  }%
  {%
    \edef\pgfmath@addtocounttemp{\the#1}%
    \pgfmathparse{#2}%
     \afterassignment\pgfmath@gobbletilpgfmath@%
     #1\pgfmathresult\relax\pgfmath@%
     \advance#1\pgfmath@addtocounttemp%
  }%
}

\def\pgfmathsetmacro#1#2{%
	\expandafter\pgfmath@onquick#2\pgfmath@%
  {%
  		\begingroup%
    		\afterassignment\pgfmath@gobbletilpgfmath@%
    		\pgfmath@x#2pt\relax\pgfmath@%
    		\edef#1{\pgfmath@tonumber{\pgfmath@x}}%
    		\pgfmath@smuggleone{#1}
    	\endgroup%
  }%
  {%
    \pgfmathparse{#2}%
    \edef#1{\pgfmathresult}%
  }%
}

% Check whether a given parameter starts with quick.
%
% The command should be followed by nonempty text, ending with
% \pgfmath@ as a stop-token. Then should follow
%
% #1 = code to execute if text starts with +
% #2 = code to execute if text does not
%
% Example:
%
% \pgfmath@onquick+0pt\pgfmath@{is quick}{is slow}

\def\pgfmath@onquick{%
  \afterassignment\pgfmath@afterquick%
  \let\pgfmath@next=%
}

\def\pgfmath@afterquick#1\pgfmath@{%
  \ifx\pgfmath@next+%
    \expandafter\pgfmath@firstoftwo%
  \else%
    \expandafter\pgfmath@secondoftwo%
  \fi%
}


% \pgfmathanglebetweenpoints *** I AM CURRENTLY NOT WORKING ***
%
% Determines the angle (in degrees) between two points.
%
% #1 - the macro in which to store the angle.
% #2 - the first (reference) point.
% #3 - the second point
%
% e.g.
%
% \pgfmathanglebetweenpoints\myangle{\pgfpointorigin}{\pgfpoint{3cm}{4cm}}
%
\def\pgfanglebetweenpoints#1#2#3{%
	\pgf@process{#3}%
	\pgf@xa\pgf@x%
	\pgf@ya\pgf@y%
	\pgf@process{#2}%
	\advance\pgf@xa-\pgf@x%
	\advance\pgf@ya-\pgf@y%	
	\pgf@x\pgf@xa%
	\pgf@y\pgf@ya%
	\ifdim\pgf@x<0pt\relax%
		\pgf@x-\pgf@x%
	\fi%
	\ifdim\pgf@y<0pt\relax%
		\pgf@y-\pgf@y%
	\fi%
	\ifdim\pgf@y<\pgf@x%
		\pgf@xb\pgf@x%
		\pgf@x\pgf@y%
		\pgf@y\pgf@xb%
	\fi%
	\pgfmathreciprocal@{\pgfmath@tonumber{\pgfmath@y}}%
	\pgfmath@y\pgfmathresult\pgfmath@x\relax%
	\multiply\pgf@y1000\relax%
	\afterassignment\pgfmath@gobbletilpgfmath@%
	\expandafter\c@pgfmath@counta\the\pgf@y\relax\pgfmath@%
	\ifnum\c@pgfmath@counta>1000\relax\c@pgfmath@counta100\relax\fi% Hmm... sometimes necessary.
	\expandafter\pgf@xc\csname pgfmath@atan@\the\c@pgfmath@counta\endcsname pt\relax%
	\ifdim\pgfmath@ya>\pgfmath@xa\relax%
		\pgf@xc-\pgf@xc%
		\advance\pgf@xc90pt\relax%
	\fi%
	\ifdim\pgf@xa<0pt\relax%
		\pgf@xc-\pgf@xc%
		\ifdim\pgf@ya>0pt\relax%
			\advance\pgf@xc180pt\relax%
		\else%
			\advance\pgf@xc270pt\relax%
		\fi%
	\else%
		\ifdim\pgf@ya<0pt\relax%
			\pgf@xc-\pgf@xc%
			\advance\pgf@xc360pt\relax%
		\fi%
	\fi%
	\edef#1{\pgfmath@tonumber{\pgf@xc}}%
}

% \pgfdistancebetweenpoints
%
% Determines Euclidian distance (in points) between two points.
%
% #1 - the dimen register in which to store the angle.
% #2 - the first (reference) point.
% #3 - the second point
%
% e.g.
%
% \pgfmathdistancebetweenpoints\pgf@x{\pgfpointorigin}{\pgfpoint{3cm}{4cm}}
%
\def\pgfdistancebetweenpoints#1#2#3{%
	\pgf@process{#3}%
	\ifdim\pgfmath@x<0pt\relax\pgfmath@x-\pgfmath@x\fi%
	\ifdim\pgfmath@y<0pt\relax\pgfmath@y-\pgfmath@y\fi%
	\pgf@xa\pgf@x%
	\pgf@ya\pgf@y
	\pgf@process{#2}%
	\ifdim\pgfmath@x<0pt\relax\pgfmath@x-\pgfmath@x\fi%
	\ifdim\pgfmath@y<0pt\relax\pgfmath@y-\pgfmath@y\fi%
	\advance\pgf@xa-\pgf@x%
	\advance\pgf@ya-\pgf@y%	
	\pgf@x\pgf@xa%
	\pgf@y\pgf@ya%
	\pgfmathveclen@{\pgfmath@tonumber{\pgfmath@x}}{\pgfmath@tonumber{\pgfmath@y}}%
	#1\pgfmathresult pt\relax%
}

% \pgfpathstar
%
% Create a path in the shape of a star.
%
% #1 - a coordinate.
% #2 - the number of points.
% #3 - the outer point radius.
% #4 - the inner point radius.
%
\def\pgfpathstar#1#2#3#4{%
	\pgfmathsetmacro\pgf@pathstarangle{+90}%
	\pgfmathsetmacro\pgf@pathstaranglestep{180/#2}%
	\pgfmathtruncate\pgf@pathstarpoints{#2*2-1}%
	\pgfmathsetmacro\pgf@pathstarouterpointradius{#3}%
	\pgfmathsetmacro\pgf@pathstarinnerpointradius{#4}%
	\pgfpathmoveto{\pgfpointadd{#1}{\pgfpoint{+0pt}{+\pgf@pathstarouterpointradius pt}}}%
	\pgfmathloop%
	\expandafter\ifnum\pgfmathcounter>\pgf@pathstarpoints%
	\else%
		\pgfmathsetmacro\pgf@pathstarangle{\pgf@pathstarangle+\pgf@pathstaranglestep}%
		\expandafter\ifodd\pgfmathcounter%
			\pgfpathlineto{%
				\pgfpointadd{#1}{\pgfpointpolar{+\pgf@pathstarangle}%
					{+\pgf@pathstarinnerpointradius pt}}}%
		\else
			\pgfpathlineto{%
			\pgfpointadd{#1}{\pgfpointpolar{+\pgf@pathstarangle}%
				{+\pgf@pathstarouterpointradius pt}}}%
		\fi
		\repeatpgfmathloop%
	\pgfpathclose%
}

% \pgfmathtruncate#1#2
% 
% Define #1 as the truncated result of #2
%
\def\pgfmathtruncate#1#2{%
	\begingroup%
		\pgfmathsetcount\c@pgfmath@counta{#2}%
		\edef#1{\the\c@pgfmath@counta}%
		\pgfmath@smuggleone{#1}%
	\endgroup}
	
% \pgfpathpolygon
%
% Create a path in the shape of a polygon.
%
% #1 - a coordinate.
% #2 - the number of points.
% #3 - the outer point radius.
% #4 - the inner point radius.
%
\def\pgfpathpolygon#1#2#3{%
	\pgfmathsetmacro\pgf@pathpolygonangle{+90}%
	\pgfmathtruncate\pgf@pathpolygonsides{#2}%
	\pgfmathsetmacro\pgf@pathpolygonanglestep{360/#2}%
	\pgfmathsetmacro\pgf@pathpolygonradius{#3}%
	\pgfpathmoveto{%
		\pgfpointadd{#1}{\pgfpointpolar{+\pgf@pathpolygonangle}%
				{+\pgf@pathpolygonradius pt}}}%
	\pgfmathloop%
	\expandafter\ifnum\pgfmathcounter<\pgf@pathpolygonsides%
		\pgfmathsetmacro\pgf@pathpolygonangle{\pgf@pathpolygonangle+\pgf@pathpolygonanglestep}%
		\pgfpathlineto{%
		\pgfpointadd{#1}{\pgfpointpolar{+\pgf@pathpolygonangle}%
				{+\pgf@pathpolygonradius pt}}}%
	\repeatpgfmathloop%
	\pgfpathclose%
}