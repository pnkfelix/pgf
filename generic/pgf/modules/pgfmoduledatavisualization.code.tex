% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS $Header: /cvsroot/pgf/pgf/generic/pgf/modules/pgfmoduledatavisualization.code.tex,v 1.10 2008/06/09 10:29:49 tantau Exp $

\usepgfmodule{oo,shapes}


% This module defines the basic framework for data visualization. 

% In order to visualize data, you first need data. The format for this
% data is not specified, indeed, different formats are possible. A
% data point is created each time the command \pgfdatapoint is
% used. The "parameters" of the data point are just the current values
% of the keys or macros in the current scope. 
%
% A set of data points created using the \pgfdataset command. Inside a
% data set, you can use \pgfdatacluster and \endpgfdatacluster to
% further cluster data. These will cause the "begin data cluster" and
% "end data cluster" signals to be emitted. Every data set implicitly
% opens a cluster. 
%
% When a data point is created, a number of signals are emitted, see
% the description of \pgfdatapoint. To actually visualize something,
% objects should be created that listen to these signals and that
% handle them. 
%
% The command \pgfnewdatavisualization inits these signals. 


% Initialize a data visualization
%
% Description:
%
% Use this command to start a data visualization. It creates the
% necessary listeners (this works also with nesting).

\def\pgfnewdatavisualization{%
  \pgfoonew \pgfsignalpreparedatapoint=new signal()%
  \pgfoonew \pgfsignalmapdatapoint=new signal()%
  \pgfoonew \pgfsignaltransformdatapoint=new signal()%
  \pgfoonew \pgfsignalvisualizedatapoint=new signal()%
  \pgfoonew \pgfsignalfinishdatapoint=new signal()%
  \pgfoonew \pgfsignalsurveydatapoint=new signal()%
  \pgfoonew \pgfsignalphase=new signal()%
}      

% The phase signal will emit the following constants:
\def\pgfdvbeginsurvey{1}
\def\pgfdvendsurvey{2}
\def\pgfdvbeginvisualization{3}
\def\pgfdvendvisualization{4}



% Create and handle a data point
%
% Description:
%
% This command is called by data parses wheneven a complete data point
% has been produced. Depending on the current circumstances, different
% signals will be emitted.
%
% The data that is represented by the data point is not given as a
% parameter. Rather, it is stored in macros and keys, that is, the
% data point is conceptually given by the settings of all the keys and
% macros in the local scope.
%
% There are two phases to data processing: In the survey phase data
% points are produced and handled in order to find out things like
% their number or the minimum and maximum values of attributes, so
% that axes and picture sizes can be prepared correctly. In the
% visualization phase, data point are actually shown. 
%
% During the survey phase, for each data point the signal
% "surveydatapoint" is emitted.
%
% During the visualization phase, more signals are emitted. A prepare
% signal is emitted first, giving all objects a 
% chance to "prepare" for the data point. Note that it is permissible
% for an object to manipulate the data point here (and also
% in later on).
%
% Next, the command \pgfcanvaspositionofdatapoint is called. Mainly, the effect
% of this command is to setup the keys /data point/canvas x and /data
% point/canvas y, see the description of this command for more
% details. 
%
% The next step consists of signaling "visualize data point". Objects
% listening to this will cause some form of visualization of the
% data point to occur. 
%
% Before the visualization is started, it is checked whether the key
% /data point/name is set (to a non-empty value). If so,
% a coordinate is created with the given canvas x and y values and
% this key's value as name.
%
% Finally, finish data point allows objects to do any final processing
% of the data point.

\def\pgfdatapoint@surveyphase{%
  \pgfsignalsurveydatapoint.emit()%
}

\def\pgfdatapoint@visualizationphase{%
  \pgfsignalpreparedatapoint.emit()%
  \pgfcanvaspositionofdatapoint%
  \pgfkeysifdefined{/data point/name}
  {%
    \pgfcoordinate{\pgfkeysvalueof{/data point/name}}{\pgfpointcanvasposition}%
  }{}%
  \pgfsignalvisualizedatapoint.emit()%
  \pgfsignalfinishdatapoint.emit()%
}



% Compute a position of a data point
%
% Description:
%
% This command uses a special signal to compute the position where a
% data point should be visualized on the canvas. In detail, the
% following happens:
%
% A local scope is created and the
% transformation matrix is reset. Then, two signals are emitted: First,
% "map data points" and then "transform data point". The first
% lets listening objects "map" the object by setting up
% attributes of the data point. The second asks objects
% listening to this signal to transform  the current transformation
% matrix. After the signals, we compute where 
% the origin lies inside this transformed coordinate system. Then the
% two keys /data point/canvas x and /data point/canvas y are set to
% the values of this position. The local scope ends (but the settings
% of the keys persist by a bit of magic), thus restoring the
% transformation matrix to its original value.

\def\pgfcanvaspositionofdatapoint{%
  \pgf@canvaspositionofdatapoint{\pgfdatapointvirtualfalse}%
}
\def\pgf@canvaspositionofdatapoint#1{%
  {
    \pgftransformreset
    #1%
    \pgfsignalmapdatapoint.emit()%
    \pgfsignaltransformdatapoint.emit()%
    \pgfpointtransformed{\pgfpointorigin}
    % Smuggle outside group
    \expandafter
  }%
  \edef\pgf@marshal{%
    \noexpand\pgfkeyssetvalue{/data point/canvas x}{\the\pgf@x}
    \noexpand\pgfkeyssetvalue{/data point/canvas y}{\the\pgf@y}
  }%
  \pgf@marshal%
}

% Help functions for locating a canvas data point
%
% Description:
%
% The first function returns the data point computed by a
% canvasposition... call. The second function stores this position in
% a macro

\def\pgfpointcanvasposition{%
  \pgfqpoint{\pgfkeysvalueof{/data point/canvas x}}{\pgfkeysvalueof{/data point/canvas y}}%
}

\def\pgfsettocanvasposition#1{%
  \edef#1{\noexpand\pgfqpoint{\pgfkeysvalueof{/data point/canvas x}}{\pgfkeysvalueof{/data point/canvas y}}}%
}



% Compute a position of a virtual data point
%
% Description:
%
% This macros works like the previous macro, but the data point is
% considered to be "virtual". This happens when you wish to compute
% the position where a data point should be visualized even when no
% "real" data point is there. For virtual data points, bounders and
% coordinate trackers should not update internal data
% structures. They can detect whether a data point is virtual by
% testing \ifpgfdatapointvirtual

\newif\ifpgfdatapointvirtual
\def\pgfcanvaspositionofvirtualdatapoint{%
  \pgf@canvaspositionofdatapoint{\pgfdatapointvirtualtrue}%
}

\pgfkeys{% do not even think of changing the values of the following:
  /data point/always true/.initial=true,
  /data point/always false/.initial=false,
  /data point/always 0/.initial=0,
  /data point/always 1/.initial=1,
  /data point/always empty/.initial=%
}




%
%
% Data parsing and formatting
%
%



% Run the rendering pipeline on a dataset.
% 
% #1 = options with path /pgf/data visualization/
% #2 = a list of data sets, each starting with \dataset. This argument
%      should either "look like" a normal 
%      argument in curly braces (even though it will be parsed
%      differently). Alternatively, if it is does not start with a
%      curly brace, this argument ends with the first command other
%      than \par or \dataset (such as \end, for instance).
%
% Description:
%
% This command is used to render data sets. A data set consists of a
% list of calls to \dataset. Data can be in different formats, as
% specified by the "format" key, and you can define new formats. 
%
% In detail, the following happens:
%
% Both for the whole data set and for each \dataset group, a scope is
% opened and the options are executed. This results in 
% some keys to be set. Two keys are handled in a special way:
%
% /pgf/data visualization/format stores the format (see below)
% /pgf/data visualization/source determines where the data is.
%
% Both the format and the source can change for each \dataset group. If
% source is empty, the data is stored in the argument that
% follows. Otherwise, the file whose name is stored in source is read.  
%
% Independently of what source is used, a format handler is started
% for each data. This works as follows: first, the handler's startup
% code is executed. Then for each line of the data file, the line
% handler function is called. Finally, the data format end handler is
% called. 
%
% The format handler's job is to call \pgfdatapoint each time a
% complete data point has been produced.
%
% The whole format handling will be run twice for each data set. The
% first time, the \pgfdatapoint command will only emit survey signals,
% the second time the actual visualization signals are emitted. Only
% upon the second run the data set signals will be emitted around
% the data.
%
% Example:
%
%   \pgfdataset
%     [format=space separated columns,
%      column 1=dax/low,
%      column 2=dax/high,
%      column 3=dax/entry,
%      column 4=dax/exit]
%    {
%      \dataset
%      {
%       % today
%       2000 2300 2100 2200 
%       2000 2350 2200 2500
%       2200 2300 2250 2260 
%       1800 2260 2260 1900 
%       2000 2300 2100 2200
%     };
%    
%     \dataset[format=comma separated columns]
%     {
%       % yesterday
%       2000, 2350, 2200, 2250 
%       2200, 2300, 2250, 2260 
%     };
%     \dataset[source=data,format=comma separated columns];
%   }


\def\pgfdatavisualizationrender{\pgfutil@ifnextchar[{\pgf@dataset}{\pgf@dataset[]}}%}


%
% Collection of \dataset groups into \pgf@dataset@collection
% 

\def\pgf@dataset[#1]{%
  \bgroup%
    \pgfkeys{/pgf/data visualization/.cd,#1}%
    % Ok, let's start collecting 
    \let\pgf@dataset@collection\pgfutil@empty%
    \pgfutil@ifnextchar\bgroup{%
      % Get rid of bgroup:
      \afterassignment\pgf@dataset@collector%
      \let\pgf@next%
    }{%
      \pgf@dataset@collector%
    }%
}
\def\pgf@dataset@collector{%
  \pgfutil@ifnextchar\egroup{\pgf@dataset@collector@stop}
  {\pgfutil@ifnextchar\par{\afterassignment\pgf@dataset@collector\let\pgf@next}
    {\pgfutil@ifnextchar\dataset{\pgf@dataset@data}{\pgf@dataset@collector@stop\egroup}}}%
}

\def\pgf@dataset@data\dataset{%
  \pgfutil@ifnextchar[{\pgf@dataset@data@opt}{\pgf@dataset@data@opt[]}}%}
\def\pgf@dataset@data@opt[#1]{%
  % Ok, add one data thing...
  \expandafter\def\expandafter\pgf@dataset@collection\expandafter{\pgf@dataset@collection\pgf@do@data{#1}}%
  \begingroup%
    \pgfkeys{/pgf/data visualization/.cd,/pgf/every data/.try,#1}%
    \pgfkeysgetvalue{/pgf/data visualization/format}\pgf@dv@format%
    \expandafter\let\expandafter\pgf@dv@format@catcodes\csname pgfdv@format@\pgf@dv@format @catcodes\endcsname%
    \ifx\pgf@dv@format@catcodes\relax
      \PackageError{pgf}{Unknown data format '\pgf@dv@format'}{}%
    \else%
      \pgfkeysgetvalue{/pgf/data visualization/source}\pgf@dv@source%
      \ifx\pgf@dv@source\pgfutil@empty%
        \let\pgf@next\pgf@dataset@grab@inline%
      \else%
        \let\pgf@next\pgf@dataset@grab@external%
      \fi%
      \pgf@next%
}
\def\pgf@dataset@grab@inline{%
  \pgfutil@ifnextchar\bgroup{%
    \begingroup%
    \catcode`\^^M=\active%
    \pgf@dv@format@catcodes%
    \pgf@dataset@grab@@inline}%
  {\PackageError{pgf}{Opening brace expected}{}}%
}
\def\pgf@dataset@grab@external{%
    \fi%
  \endgroup%
  \expandafter\def\expandafter\pgf@dataset@collection\expandafter{\pgf@dataset@collection{\pgf@dataset@do@external}}%
  \pgf@dataset@collector%
}

{\catcode`\^^M=\active%
  \gdef\pgf@dataset@grab@@inline#1{%
    \endgroup%
    \expandafter\def\expandafter\pgf@dataset@collection\expandafter{\pgf@dataset@collection{\pgf@dataset@do@inline#1^^M\pgf@@eol}}%
    \fi%
  \expandafter\endgroup%
  \expandafter\def\expandafter\pgf@dataset@collection\expandafter{\pgf@dataset@collection}%  
  \pgf@dataset@collector%
  }%
}%
\def\pgf@@eol{\pgf@eol}


%
% Running the two phases after the collecting is done.
%

\def\pgf@dataset@collector@stop{%
    % Survey phase.
    \let\pgfdatapoint=\pgfdatapoint@surveyphase%
    \pgfsignalphase.emit(\pgfdvbeginsurvey)%
    \pgf@dataset@collection%
    \pgfsignalphase.emit(\pgfdvendsurvey)%
    % Visualization phase.
    \pgfsignalphase.emit(visualization)%
    \let\pgfdatapoint=\pgfdatapoint@visualizationphase%
    \pgfsignalphase.emit(\pgfdvbeginvisualization)%
    \pgf@dataset@collection%
    \pgfsignalphase.emit(\pgfdvendvisualization)%
}

\def\pgf@do@data#1#2{%
  \begingroup%
    \pgfkeys{/pgf/data visualization/.cd,#1}%
    \pgfkeysgetvalue{/pgf/data visualization/format}\pgf@dv@format%
    \expandafter\let\expandafter\pgf@dv@format@line\csname pgfdv@format@\pgf@dv@format @line\endcsname%
    \expandafter\let\expandafter\pgf@dv@format@emptyline\csname pgfdv@format@\pgf@dv@format @empty\endcsname%
    \csname pgfdv@format@\pgfkeysvalueof{/pgf/data visualization/format}@startup\endcsname%
    #2%
    \csname pgfdv@format@\pgfkeysvalueof{/pgf/data visualization/format}@end\endcsname%
  \endgroup%
}


%
% Read external file
%

\def\pgf@dataset@do@external{%
  \csname pgfdv@format@\pgfkeysvalueof{/pgf/data visualization/format}@catcodes\endcsname%
  \immediate\openin1=\pgfkeysvalueof{/pgf/data visualization/source} %
  \ifeof1\relax
     \PackageError{pgf}{Data source '\pgfkeysvalueof{/pgf/data visualization/source}' not found}{}%
  \else
    \pgf@dataset@readline%
  \fi
  \immediate\closein1%
}

\def\pgf@partext{\par}%
\def\pgf@dataset@readline{%
  \immediate\read1 to \pgf@temp%
  \ifx\pgf@temp\pgf@partext%
    \pgf@dv@format@emptyline%
  \else%
    \ifx\pgf@temp\pgfutil@empty%
      \pgf@dv@format@emptyline%
    \else%
      \expandafter\pgf@dv@format@line\pgf@temp\pgfeol%
    \fi%
  \fi%
  \ifeof1\else\expandafter\pgf@dataset@readline\fi%
}


%
% Read inline data
%

\def\pgf@dataset@do@inline{%
  \pgf@dv@handle@line%
}

{\catcode`\^^M=\active%
\gdef\pgf@dv@handle@line{%
  \pgfutil@ifnextchar^^M{\pgf@dv@format@emptyline\expandafter\pgf@dv@handle@line\pgfutil@gobble}%
  {\pgfutil@ifnextchar\pgf@@eol{\pgfutil@gobble}{\pgf@dv@handle@nonemptyline}}%
}%
\gdef\pgf@dv@handle@nonemptyline#1^^M{%
  \pgf@dv@format@line#1\pgfeol%
  \pgf@dv@handle@line%
}%
}

\pgfkeys{
  /pgf/data visualization/format/.initial=,
  /pgf/data visualization/source/.initial=
}






% Define a data format
%
% #1 = format name
% #2 = catcode code
% #3 = startup code
% #4 = line arguments
% #5 = line code
% #6 = empty line code
% #7 = end code
%
% Description:
%
% This command defines a new data format for data visualization. When
% a data set is visualized and the format is set to #1, this handler
% is used to parse the data.
%
% In detail, the \dataset command will select a source. Before this
% source is read, #2 will be executed to setup the
% catcodes. Additionally, each time the data is parsed, #3 will be
% called. Then, for each nonempty line of the source, the
% command #5 is executed, where the line will be matched against the
% argument pattern given in #4. For empty lines, #6 will be executed
% instead. At the end of the source, #7 will be executed.

\def\pgfdeclaredataformat#1#2#3#4#5#6#7{%
  \expandafter\def\csname pgfdv@format@#1@catcodes\endcsname{#2}%
  \expandafter\def\csname pgfdv@format@#1@startup\endcsname{#3}%
  \expandafter\def\csname pgfdv@format@#1@line\endcsname#4\pgfeol{#5}%
  \expandafter\def\csname pgfdv@format@#1@empty\endcsname{#6}%
  \expandafter\def\csname pgfdv@format@#1@end\endcsname{#7}%
}



%
% Predefined standard formats
%

% TeX code format
%
% Description:
%
% The lines of the data set are assumed to contains executable TeX
% code that will call \pgfdatapoint.
%
% Example:
%
% \pgfdatavisualizationrender[format=TeX code]
% \dataset{
%   \pgfkeyssetvalue{/data point/x}{5}
%   \pgfkeyssetvalue{/data point/y}{5}
%   \pgfdatapoint
%   \pgfkeyssetvalue{/data point/x}{6}
%   \pgfkeyssetvalue{/data point/y}{6}
%   \pgfdatapoint
% }

\pgfdeclaredataformat{TeX code}{}{}{#1}{#1 }{}{}



% Key-value lines format
%
% Description:
%
% The lines of the data set are passed to \pgfkeys with the path set
% to /data point.
%
% Example:
%
% \pgfdatavisualizationrender[format=key value pairs]
% \dataset{
%   x=5, y=6, hi=9
%   x=7, y=6, lo=10
% }

\pgfdeclaredataformat{key value pairs}{}{}{#1}{\pgfkeys{/data point/.cd,#1}\pgfdatapoint}{}{}



% Comma separated columns
%
% Description:
%
% Each input line for this format should contain values separated by
% commas. For each nonempty line, the first value will be stored in
% /data point/<col1>, where <col1> is the value stored in /pgf/data
% visualization/column 1, the second value is stored in /data
% point/<col2>, where <col2> is the value stored in /pgf/data
% visualization/column 2, and so on. If a <colX> is empty, the value
% is ignored.
%
% Example:
%
% \pgfdatavisualizationrender[format=space separated columns,
%             column 1=dax/low,
%             column 2=dax/high,
%             column 3=dax/entry,
%             column 4=dax/exit]
% \dataset{
%   % today
%   2000, 2300, 2100, 2200 
%   2000, 2350, 2200  
%   2200, 2300, 2250, 2260 
%   1800, 2260, 2260, 1900 
%   2000, 2300, 2100, 2200
%    
%   % yesterday
%   2000, 2350, 2200, 2250 
%   2200, 2300, 2250, 2260 
%   1800, 2260, 2260, 1900 
% }

\pgfkeys{/pgf/data visualization/.cd,
  column 1/.initial=x,
  column 2/.initial=y,
  column 3/.initial=z,
  column 4/.initial=,
  column 5/.initial=,
  column 6/.initial=,
  column 7/.initial=,
  column 8/.initial=}

\pgfdeclaredataformat{comma separated columns}{}{\pgf@dv@separated@get}{#1}
{\pgf@dv@csc#1,,,,,,,,,\pgfeol}{}{}

\def\pgf@dv@csc#1,#2,#3,#4,#5,#6,#7,#8,#9\pgfeol{%
  \ifx\pgf@dv@cola\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cola}{#1}\fi%
  \ifx\pgf@dv@colb\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colb}{#2}\fi%
  \ifx\pgf@dv@colc\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colc}{#3}\fi%
  \ifx\pgf@dv@cold\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cold}{#4}\fi%
  \ifx\pgf@dv@cole\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@cole}{#5}\fi%
  \ifx\pgf@dv@colf\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colf}{#6}\fi%
  \ifx\pgf@dv@colg\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colg}{#7}\fi%
  \ifx\pgf@dv@colh\pgfutil@empty\else\pgfkeyssetvalue{/data point/\pgf@dv@colh}{#8}\fi%
  \pgfdatapoint%
}

\def\pgf@dv@separated@get{%
  \pgfkeysgetvalue{/pgf/data visualization/column 1}\pgf@dv@cola%
  \pgfkeysgetvalue{/pgf/data visualization/column 2}\pgf@dv@colb%
  \pgfkeysgetvalue{/pgf/data visualization/column 3}\pgf@dv@colc%
  \pgfkeysgetvalue{/pgf/data visualization/column 4}\pgf@dv@cold%
  \pgfkeysgetvalue{/pgf/data visualization/column 5}\pgf@dv@cole%
  \pgfkeysgetvalue{/pgf/data visualization/column 6}\pgf@dv@colf%
  \pgfkeysgetvalue{/pgf/data visualization/column 7}\pgf@dv@colg%
  \pgfkeysgetvalue{/pgf/data visualization/column 8}\pgf@dv@colh%
}

% Space separated columns
%
% Description:
%
% Each input line for this format should contain values separated by
% spaces. Otherwise, the format works like comma separated columns.
%
% Example:
%
% \pgfdatavisualizationrender[format=space separated columns,
%             column 1=dax/low,
%             column 2=dax/high,
%             column 3=dax/entry,
%             column 4=dax/exit]
% {
%   % today
%   2000 2300 2100 2200 
%   2000 2350 2200  
%   2200 2300 2250 2260 
%   1800 2260 2260 1900 
%   2000 2300 2100 2200
%    
%   % yesterday
%   2000 2350 2200 2250 
%   2200 2300 2250 2260 
%   1800 2260 2260 1900 
% }


\pgfdeclaredataformat{space separated columns}{}{\pgf@dv@separated@get}{#1}
{\pgf@dv@ssc#1 @\pgf @ @\pgf @ @\pgf @ @\pgf @ @\pgf @ @\pgf @ @\pgf @ @\pgf @\pgfeol}{}{}

\def\pgf@dv@ssc#1 #2 #3 #4 #5 #6 #7 #8 #9\pgfeol{%
  \pgf@dv@css@handle\pgf@dv@cola{#1}%
  \pgf@dv@css@handle\pgf@dv@colb{#2}%
  \pgf@dv@css@handle\pgf@dv@colc{#3}%
  \pgf@dv@css@handle\pgf@dv@cold{#4}%
  \pgf@dv@css@handle\pgf@dv@cole{#5}%
  \pgf@dv@css@handle\pgf@dv@colf{#6}%
  \pgf@dv@css@handle\pgf@dv@colg{#7}%
  \pgf@dv@css@handle\pgf@dv@colh{#8}%
  \pgfdatapoint%
}
\def\pgf@dv@css@handle#1#2{%
  \ifx#1\pgfutil@empty%
  \else%
    \def\pgf@temp{#2}%
    \ifx\pgf@temp\pgf@atpgfattext%
      \let\pgf@temp\pgfutil@empty%
    \fi%
    \pgfkeyslet{/data point/#1}\pgf@temp%
  \fi%
}
\def\pgf@atpgfattext{@\pgf @}




%
%
% Standard objects for data visualization
% 
%


%
% Transformers
%

\pgfooclass{line transformer}
{
  % Class line transformer
  %
  % This class is a transformer class. It reacts to the transform
  % datapoint signal. When this signal is raised, it will shift the
  % coordinate system as follows: If the current value of /data
  % point/this.attribute  is
  % 0, then the system is shifted to the current value of this.origin. If
  % the current value is 1, the system is shifted to this.origin + this.unit
  % vector. For other values of /data point/this.attribuate, the shift
  % is interpolated between these two values.

  
  \attribute attribute;
  % The attribute (/data point/this.attribute) by which
  % the unit vector is multiplied. If it is empty (which is
  % different from 0), no transformation is done at all.

  \attribute origin = \pgfpointorigin;
  %   The shift in case the /data point/this.attribute is 0.

  \attribute unit vector;
  %   The coordinate system is additionally shifted by this amount
  %   times the current value of /data point/this.attribute.

  
  % Constructor
  %
  % #1 = attribute that is being transformed. Example: x
  % #2 = a vector corresponding to one unit of #1.
  %      Example: \pgfpoint{1cm}{0cm}
  \method line transformer(#1,#2) {
    \pgfooset{attribute}{#1}
    \pgfooset{unit vector}{#2}%
  }

  % Method
  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignaltransformdatapoint.connect(\pgf@dv@me,transform)
  }
  
  % Setter
  \method set origin(#1) {
    \pgfooset{origin}{#1}
  }

  % Slot 
  \method transform() {
    \pgfkeysgetvalue{/data point/\pgfoovalueof{attribute}}\pgf@dv@val%
    \ifx\pgf@dv@val\pgfutil@empty%
    \else%
      \ifx\pgf@dv@val\relax%
      \else%
        \pgftransformshift{\pgfoovalueof{origin}}%
        \pgftransformshift{\pgfpointscale{\pgf@dv@val}{\pgfoovalueof{unit vector}}}%
      \fi%
    \fi%
  }
}




%
% Mappers
%

\pgfooclass{attribute mapper}
{
  % Class attribute mapper
  %
  % This mapper reacts to the map datapoint signal. Its purpose is to
  % map one attribute to another attribute. For the first attribute, a
  % range [a,b] is specified and another range [c,d] is specifed for
  % the second. Values in the range [a,b] are linearly mapped to the
  % range [c,d] and the result is stored in the second attribute.
  %
  % For instance, if the first range is [10,20] and the second range
  % is [0,100], then 10 is mapped to 0, 11 is mapped to 10, 20 is
  % mapped to 100 and 30 is mapped to 200.
  %
  % It is permissible to specify an additional non-linear
  % transformation function f. In this case, for an input value x the
  % position of f(x) inside the interval [f(a),f(b)] is determined and
  % this position is linearly mapped to [c,d]. 
  %
  % For example, if f(x) = log_10 (x) and the first range [a,b] =
  % [10,1000] and the second range is [1,2], then 10 is mapped to 1,
  % 100 is mapped to 1.5 (since f(100) = 3 lies in the middle
  % between f(10) = 2 and f(1000) = 4) and 100000 is mapped to 3.
  

  \attribute in;
  % The name of the input attribute. If the value of this attribute
  % is empty or undefined, no mapping is done.
  
  \attribute out;
  % The name of the output attribute.
  
  \attribute trans;
  % Stores (more or less) transformation function.

  \attribute out min;
  % Start of the second range (the value of c).

  \attribute trans in min;
  % Transformed value of the start of the first range (the value
  % f(a)).

  \attribute scale;
  %   The scaling factor, that is, the value of (f(d)-f(c))/(b-a).

  
  % Constructor
  %
  % #1 = input attribute. Example: velocity.
  % #2 = start of input range. Example: 10
  % #3 = end of input range. Example: 20
  % #4 = output attribuate. Example: x
  % #5 = start of output range. Example: -10
  % #6 = end of output range. Example: 100
  % #7 = optional transformation function. The input value for this
  %      function is stored in the macro \pgfvalue, that is, when the
  %      function is called the macro will expand to something like
  %      "3.141". The output of the function should be stored in the
  %      macro \pgfmathresult.
  % 
  \method attribute mapper(#1,#2,#3,#4,#5,#6,#7) {
    {%
      % Let's start with the output, it's easier...
      \pgfooset{out}{#4}
      \pgfmathparse{#5}
      \pgfooeset{out min}{\pgfmathresult}
      \pgfmathsubtract{#6}{\pgfoovalueof{out min}}%
      \let\pgf@dv@out@diff=\pgfmathresult%
      % Now comes the transformation code:
      \def\pgf@temp{#7}%
      \ifx\pgf@temp\pgfutil@empty%
      \else%
        \pgfooset{trans}{%
          \let\pgfvalue\pgfmathresult%
          \pgfmathparse{#7}%
        }%
      \fi%
      % Ok, now the transformed input:
      \pgfooset{in}{#1}
      \pgfmathparse{#2}
      \pgfoovalueof{trans}%
      \let\pgf@dv@min=\pgfmathresult
      \pgfooeset{trans in min}{\pgfmathresult}
      \pgfmathparse{#3}
      \pgfoovalueof{trans}%
      \pgfmathsubtract{\pgfmathresult}{\pgfoovalueof{trans in min}}%
      % 
      % Precompute the scaling
      %
      \pgfmathdivide{\pgf@dv@out@diff}{\pgfmathresult}%
      \pgfooeset{scale}{\pgfmathresult}%
    }%
  } 

  % Method
  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignalmapdatapoint.connect(\pgf@dv@me,map)
  }

  % Slot
  \method map() {
    \pgfkeysifdefined{/data point/\pgfoovalueof{in}}
    {%
      \pgfkeysgetvalue{/data point/\pgfoovalueof{in}}\pgfmathresult%
      \ifx\pgfmathresult\pgfutil@empty%
      \else%
        \ifx\pgfmathresult\relax%
        \else%
          \pgfoovalueof{trans}%
          \pgfmathsubtract{\pgfmathresult}{\pgfoovalueof{trans in min}}%
          \pgfmathmultiply{\pgfmathresult}{\pgfoovalueof{scale}}%
          \pgfmathadd{\pgfmathresult}{\pgfoovalueof{out min}}%
          \pgfkeyslet{/data point/\pgfoovalueof{out}}\pgfmathresult%
        \fi%
      \fi%
    }
    {}% do nothing!
  }
}


\pgfooclass{polar mapper}
{
  % Class plor mapper
  %
  % A polar mapper is used to map attributes given as (2d) polar
  % coordinates to Cartesian coordinates. Note that no special ranges
  % can be specified and that the angle must be given in degrees. You
  % can, however, use attribute mappers to change these things.
  
  \attribute angle;
  % The attribute from which the angle is read.
  
  \attribute radius;
  % The attribute from which the radius is read.
  
  \attribute x;
  % The attribute to which the resulting x coordinate is written.
  
  \attribute y;
  % The attribute to which the resulting y coordinate is written. 

  
  % Constructor
  %
  % #1 = angle attribute. Example: rotation.
  % #2 = radius attribute. Example: height.
  % #3 = x attribute. Example: x.
  % #4 = y attribute. Example: y.
  %
  \method polar mapper(#1,#2,#3,#4) {
    \pgfooset{angle}{#1}
    \pgfooset{radius}{#2}
    \pgfooset{x}{#3}
    \pgfooset{y}{#4}
  } 

  % Method
  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignalmapdatapoint.connect(\pgf@dv@me,map)
  }

  % Slot
  %
  % Mapping is done only if both the angle and the radius attribute
  % have non-empty values.
  \method map() {
    \pgfkeysgetvalue{/data point/\pgfoovalueof{angle}}\pgf@dv@angle%
    \ifx\pgf@dv@angle\pgfutil@empty%
    \else%
      \ifx\pgf@dv@angle\relax%
      \else%
        \pgfkeysgetvalue{/data point/\pgfoovalueof{radius}}\pgf@dv@radius%
        \ifx\pgf@dv@radius\pgfutil@empty%
        \else%
          \ifx\pgf@dv@radius\relax%
          \else%
            \pgfmathsincos{\pgf@dv@angle}%
            \pgfmathmultiply{\pgfmathresultx}{\pgf@dv@radius}%
            \pgfkeyslet{/data point/\pgfoovalueof{x}}\pgfmathresult%
            \pgfmathmultiply{\pgfmathresulty}{\pgf@dv@radius}%
            \pgfkeyslet{/data point/\pgfoovalueof{y}}\pgfmathresult%
          \fi%
        \fi%
      \fi%
    \fi%
  }

  % Getter
  \method get angle and radius attributes() {
    \pgfooget{angle}\pgfdvangleattribute
    \pgfooget{radius}\pgfdvradiusattribute
  }
}



%
% Bounders
%

\pgfooclass{attribute bounder}
{
  \attribute attribute;
  \attribute interval obj;
  \attribute drop min;
  \attribute drop max;
  \attribute lift min;
  \attribute lift max;
  \attribute ignore min;
  \attribute ignore max;
  
  \method attribute bounder(#1,#2) {
    \pgfooset{attribute}{#1}
    \pgfoolet{interval obj}#2
  }

  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignalmapdatapoint.connect(\pgf@dv@me,map)
  }

  \method drop values below(#1) {
    \pgfooset{drop min}{#1}
  }

  \method drop values above(#1) {
    \pgfooset{drop max}{#1}
  }

  \method ignore values below(#1) {
    \pgfooset{ignore min}{#1}
  }

  \method ignore values above(#1) {
    \pgfooset{ignore max}{#1}
  }

  \method raise values lower than(#1) {
    \pgfooset{lift min}{#1}
  }

  \method lower values higher than(#1) {
    \pgfooset{lift max}{#1}
  }

  \method goto min() {
    \pgfooget{interval obj}\pgf@dv@interval
    \pgf@dv@interval.get interval()
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgfdvmin
  }

  \method goto max() {
    \pgfooget{interval obj}\pgf@dv@interval
    \pgf@dv@interval.get interval()
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgfdvmax
  }

  \method goto adjusted min() {
    \pgfooget{interval obj}\pgf@dv@interval
    \pgf@dv@interval.get adjusted interval()
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgfdvmin
  }

  \method goto adjusted max() {
    \pgfooget{interval obj}\pgf@dv@interval
    \pgf@dv@interval.get adjusted interval()
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgfdvmax
  }
  
  \method map() {
    \ifpgfdatapointvirtual%
    \else%
      \pgfkeysgetvalue{/data point/\pgfoovalueof{attribute}}\pgf@dv@val%
      \ifx\pgf@dv@val\pgfutil@empty%
      \else%
        \ifx\pgf@dv@val\relax%
        \else%
          \pgfmathparse{\pgf@dv@val}%
          % Ignore?
          \pgfooget{ignore min}\pgf@dv@ignore%
          \ifx\pgf@dv@ignore\pgfutil@empty%
          \else%
            \ifdim\pgfmathresult pt<\pgf@dv@ignore pt%
              \pgf@dvignoretrue%
            \fi%
          \fi%
          \pgfooget{ignore max}\pgf@dv@ignore%
          \ifx\pgf@dv@ignore\pgfutil@empty%
          \else%
            \ifdim\pgfmathresult pt>\pgf@dv@ignore pt%
              \pgf@dvignoretrue%
            \fi%
          \fi%
          \ifpgf@dvignore%
          \else%
            % Drop?
            \pgfooget{drop min}\pgf@dv@drop%
            \ifx\pgf@dv@drop\pgfutil@empty%
            \else%
              \ifdim\pgfmathresult pt<\pgf@dv@drop pt%
                \pgf@dvdroptrue%
              \fi%
            \fi%
            \pgfooget{drop max}\pgf@dv@drop%
            \ifx\pgf@dv@drop\pgfutil@empty%
            \else%
              \ifdim\pgfmathresult pt>\pgf@dv@drop pt%
                \pgf@dvdroptrue%
              \fi%
            \fi%
            \ifpgf@dvdrop%
              \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgfutil@empty%
            \else%
              % Lift?
              \pgfooget{lift min}\pgf@dv@lift%
              \ifx\pgf@dv@lift\pgfutil@empty%
              \else%
                \ifdim\pgfmathresult pt<\pgf@dv@lift pt%
                  \let\pgfmathresult=\pgf@dv@lift%
                  \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgfmathresult            
                \fi%
              \fi%
              % Lift?
              \pgfooget{lift max}\pgf@dv@lift%
              \ifx\pgf@dv@lift\pgfutil@empty%
              \else%
                \ifdim\pgfmathresult pt>\pgf@dv@lift pt%
                  \let\pgfmathresult=\pgf@dv@lift%
                  \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgfmathresult            
                \fi%
              \fi%
              % Now, protocol value
              \pgfooget{interval obj}\pgf@dv@interval
              \pgf@dv@interval.get interval()%
              \ifx\pgfdvmin\pgfutil@empty%
                \pgf@dv@interval.set min(\pgfmathresult)%
              \else%
                \ifdim\pgfmathresult pt<\pgfdvmin pt%
                  \pgf@dv@interval.set min(\pgfmathresult)%
                \fi%
              \fi%
              \ifx\pgfdvmax\pgfutil@empty%
                \pgf@dv@interval.set max(\pgfmathresult)%
              \else%
                \ifdim\pgfmathresult pt>\pgfdvmax pt%
                  \pgf@dv@interval.set max(\pgfmathresult)%
                \fi%
              \fi%
            \fi%
          \fi%
        \fi%
      \fi%
    \fi%
  }

  \newif\ifpgf@dvdrop
  \newif\ifpgf@dvignore
}



%
% Help class: Interval
%

\pgfooclass{interval}
{
  \attribute min;
  \attribute max;
  \attribute min adjust absolute;
  \attribute min adjust relative;
  \attribute max adjust absolute;
  \attribute max adjust relative;
  
  \method interval(#1,#2) {
    \pgfooeset{min}{#1}
    \pgfooeset{max}{#2}
  }

  \method default connects() {
  }
  
  \method set min(#1) {
    \pgfooeset{min}{#1}
  }
  \method set max(#1) {
    \pgfooeset{max}{#1}
  }
  \method set min adjust absolute(#1) {
    \pgfooset{min adjust absolute}{#1}    
  }
  \method set min adjust relative(#1) {
    \pgfooset{min adjust relative}{#1}    
  }
  \method set max adjust absolute(#1) {
    \pgfooset{max adjust absolute}{#1}    
  }
  \method set max adjust relative(#1) {
    \pgfooset{max adjust relative}{#1}    
  }

  \method get interval() {
    \pgfooget{min}\pgfdvmin
    \pgfooget{max}\pgfdvmax
  }

  \method get adjusted interval() {
    \pgfooget{min}\pgfdvmin
    \pgfooget{max}\pgfdvmax
    \ifx\pgfdvmin\pgfutil@empty%
    \else%
      \ifx\pgfdvmax\pgfutil@empty%
      \else%
        \pgfooget{min adjust absolute}\pgf@dv@minpa
        \pgfooget{min adjust relative}\pgf@dv@minpr
        \pgfooget{max adjust absolute}\pgf@dv@maxpa
        \pgfooget{max adjust relative}\pgf@dv@maxpr
        \pgfmathsubtract{\pgfdvmax}{\pgfdvmin}%
        \let\pgf@dv@diff\pgfmathresult%
        % Start with minimum
        \let\pgfmathresult\pgfdvmin%
        \ifx\pgf@dv@minpa\pgfutil@empty%
        \else%
          \pgfmathadd{\pgfmathresult}{\pgf@dv@minpa}%
        \fi%
        \ifx\pgf@dv@minpr\pgfutil@empty%
        \else%
          \pgfmathadd{\pgfmathresult}{\pgf@dv@minpr*\pgf@dv@diff}%
        \fi%
        \let\pgfdvmin\pgfmathresult%  
        % Maximum next
        \let\pgfmathresult\pgfdvmax%
        \ifx\pgf@dv@maxpa\pgfutil@empty%
        \else%
          \pgfmathadd{\pgfmathresult}{\pgf@dv@maxpa}%
        \fi%
        \ifx\pgf@dv@maxpr\pgfutil@empty%
        \else%
          \pgfmathadd{\pgfmathresult}{\pgf@dv@maxpr*\pgf@dv@diff}%
        \fi%
        \let\pgfdvmax\pgfmathresult%  
      \fi%
    \fi%
  }
}


\pgfooclass{count up}
{
  \attribute attribute;
  \attribute val=0;
  
  \method count up(#1) {
    \pgfooset{attribute}{#1}
  }

  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignalpreparedatapoint.connect(\pgf@dv@me,apply)
  }

  \method set value(#1) {
    \pgfooset{val}{#1}
    \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{#1}%
  }

  \method apply() {
    {%
      \c@pgf@counta=\pgfoovalueof{val}\relax%
      \advance\c@pgf@counta by1\relax%
      \pgfooeset{val}{\the\c@pgf@counta}%
    }%
    \pgfooget{val}\pgf@dv@temp%
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgf@dv@temp%
  }  
}


\pgfooclass{count down}
{
  \attribute attribute;
  \attribute max;
  \attribute val;
  
  \method count down(#1,#2) {
    \pgfooset{attribute}{#1}
    \pgfooset{max}{#2}
    \pgfooset{val}{#2}
  }

  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignalpreparedatapoint.connect(\pgf@dv@me,apply)
  }

  \method set value(#1) {
    \pgfooset{val}{#1}
    \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{#1}%
  }

  \method apply() {
    {%
      \c@pgf@counta=\pgfoovalueof{val}\relax%
      \advance\c@pgf@counta by-1\relax%
      \ifnum\c@pgf@counta<0\relax%
        \advance\c@pgf@counta by\pgfoovalueof{max}\relax%
      \fi%
      \pgfooeset{val}{\the\c@pgf@counta}%
    }%
    \pgfooget{val}\pgf@dv@temp%
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}}\pgf@dv@temp%
  }  
}



\pgfooclass{sum}
{
  \attribute attribute;
  \attribute sum=0;
  
  \method sum(#1) {
    \pgfooeset{attribute}{#1}
    \pgfkeyssetvalue{/data point/#1/prev sum}{0}
    \pgfkeyssetvalue{/data point/#1/sum}{0}
  }

  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignalpreparedatapoint.connect(\pgf@dv@me,apply)
  }

  \method apply() {
    \pgfooget{sum}\pgf@temp
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}/prev sum}\pgf@temp
    \pgfmathadd{\pgfkeysvalueof{/data point/\pgfoovalueof{attribute}}}{\pgfoovalueof{sum}}
    \pgfoolet{sum}\pgfmathresult
    \pgfkeyslet{/data point/\pgfoovalueof{attribute}/sum}\pgfmathresult
  }
}


%
% Axes
%

\pgfooclass{straight axis}
{
  \attribute attribute;
  \attribute interval obj;
  \attribute tick vec;
  \attribute use path=\pgfusepath{stroke};
  \attribute use tick path=\pgfusepath{stroke};
  
  \method straight axis(#1,#2) {
    \pgfooset{attribute}{#1}
    \pgfoolet{interval obj}#2
  }

  \method default connects() {
  }

  \method set use path(#1) {
    \pgfooset{use path}{#1}
  }
  
  \method set use tick path(#1) {
    \pgfooset{use tick path}{#1}
  }
  
  \method visualize() {
    {%
      % we assume that the current data point settings determine where
      % the axis should go
      %
      % We now compute the start and the end points
      %
      \pgfooget{interval obj}\pgf@dv@interval
      \pgf@dv@interval.get adjusted interval()%
      % Ok, got the values
      % Save them.
      \let\pgf@dv@sa@min=\pgfdvmin
      \let\pgf@dv@sa@max=\pgfdvmax
      \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{\pgf@dv@sa@min}%
      \pgfcanvaspositionofvirtualdatapoint%
      % Ok, that's where we start
      \pgfpathmoveto{\pgfpointcanvasposition}%
      % now the end:
      \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{\pgf@dv@sa@max}%
      \pgfcanvaspositionofvirtualdatapoint%
      \pgfpathlineto{\pgfpointcanvasposition}%
      % Finally, use the path:
      \pgfoovalueof{use path}%
    }%
  }

  \method visualize as tick() {
    \pgfooget{tick vec}\pgf@dv@vec% cached tick vec
    \ifx\pgf@dv@vec\pgfutil@empty%
      {%
        %
        % This is only to compute the correct direction vector
        %
        \pgfooget{interval obj}\pgf@dv@interval
        \pgf@dv@interval.get interval()%
        % Ok, got the values
        % Save them.
        \let\pgf@dv@sa@min=\pgfdvmin
        \let\pgf@dv@sa@max=\pgfdvmax
        \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{\pgf@dv@sa@min}%
        \pgfcanvaspositionofvirtualdatapoint%
        \pgf@process{\pgfpointcanvasposition}
        \pgf@xc=\pgf@x%
        \pgf@yc=\pgf@y%
        % now the end:
        \pgfkeyssetvalue{/data point/\pgfoovalueof{attribute}}{\pgf@dv@sa@max}%
        \pgfcanvaspositionofvirtualdatapoint%
        \pgf@process{\pgfpointnormalised{\pgfpointdiff{\pgfqpoint{\pgf@xc}{\pgf@yc}}{\pgfpointcanvasposition}}}
      }
      \edef\pgf@dv@vec{\noexpand\pgfqpoint{\the\pgf@x}{\the\pgf@y}}%
      \pgfoolet{tick vec}\pgf@dv@vec%
    \fi%
    \pgfcanvaspositionofvirtualdatapoint%
    {%
      \pgftransformshift{\pgfpointcanvasposition}%
      \pgfmathparse{\pgfkeysvalueof{/data point/tick lower length}}
      \pgfpathmoveto{\pgfpointscale{-\pgfmathresult}{\pgf@dv@vec}}
      \pgfmathparse{\pgfkeysvalueof{/data point/tick higher length}}
      \pgfpathlineto{\pgfpointscale{\pgfmathresult}{\pgf@dv@vec}}
      \pgfoovalueof{use tick path}%
    }%
  }
}



\pgfooclass{polar axis}
{
  \attribute mapper obj;
  \attribute interval obj;
  \attribute use patch=\pgfusepath{stroke};
  
  \method polar axis(#1,#2) {
    \pgfoolet{mapper obj}#1
    \pgfoolet{interval obj}#2
  }

  \method default connects() {
  }

  \method set use path(#1) {
    \pgfooset{use path}{#1}
  }
  
  \method visualize axis() {
    {%
      %
      \pgfooget{mapper obj}\pgf@dv@trans%
      \pgf@dv@trans.get angle and radius attributes()%
      % we assume that the current data point settings determine where
      % the axis should go
      %
      % we also assume that the axis will, indeed, be visualized as an
      % arc. 
      %
      % Compute the origin:
      {%
        \pgfkeyssetvalue{/data point/\pgfdvradiusattribute}{0}%
        \pgfcanvaspositionofvirtualdatapoint%
        \pgfsettocanvasposition\pgf@temp
        \global\let\pgf@dv@temp@orig=\pgf@temp%
      }%
      % Compute the first axis:
      \pgfkeyssetvalue{/data point/\pgfdvangleattribute}{0}%
      \pgfcanvaspositionofvirtualdatapoint%
      \pgfsettocanvasposition\pgf@dv@veczero%
      % Compute the second axis:
      \pgfkeyssetvalue{/data point/\pgfdvangleattribute}{90}%
      \pgfcanvaspositionofvirtualdatapoint%
      \pgfsettocanvasposition\pgf@dv@vecninety%
      %
      % Start and end angle
      %
      \pgfooget{interval obj}\pgf@dv@interval
      \pgf@dv@interval.get adjusted interval()%
      % Ok, got the values
      % Compute the first axis:
      \pgfkeyssetvalue{/data point/\pgfdvangleattribute}{\pgfdvmin}%
      \pgfcanvaspositionofvirtualdatapoint%
      \pgfpathmoveto{\pgfpointcanvasposition}%
      % Do arc:
      \pgftransformtriangle{\pgf@dv@temp@orig}{\pgf@dv@veczero}{\pgf@dv@vecninety}%
      \pgfpatharc{\pgfdvmin}{\pgfdvmax}{1pt}%
      % Finally, use the path:
      \pgfoovalueof{use path}%
    }%
  }
}





%
% Visualizers
%

\usepgflibrary{plothandlers}


\pgfooclass{plot mark visualizer}
{
  \attribute mark;
  \attribute zero trigger=always 0;
  \attribute size=\pgfplotmarksize;
  
  \method plot mark visualizer(#1) {
    \pgfooeset{mark}{#1}
  }

  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignalvisualizedatapoint.connect(\pgf@dv@me,visualize)
  }

  \method set size(#1) {
    \pgfooset{size}{#1}
  }

  \method set zero trigger(#1) {
    \pgfooset{zero trigger}{#1}
  }
  
  \method visualize() {
    {%
      \pgfkeysgetvalue{/data point/\pgfoovalueof{zero trigger}}\pgf@dv@trig%
      \ifx\pgf@dv@trig\pgf@dv@zero@text%
        \pgfplotmarksize\pgfoovalueof{size}
        \pgftransformshift{\pgfpointcanvasposition}
        \pgfuseplotmark{\pgfoovalueof{mark}}
      \fi%
    }%
  }

  \def\pgf@dv@zero@text{0}
}



\pgfooclass{plot handler visualizer}
{
  \attribute handler;
  \attribute use path=\pgfusepath{stroke};
  \attribute positions;
  
  \method plot handler visualizer(#1) {
    \pgfooset{handler}{#1}
  }

  \method default connects() {
    \pgfoothis.object(\pgf@dv@me)
    \pgfsignalvisualizedatapoint.connect(\pgf@dv@me,protocol)
    \pgfsignalphase.connect(\pgf@dv@me,render)
  }

  \method set use path(#1) {
    \pgfooset{use path}{#1}
  }
  
  \method protocol() {
    % Just append it to positions
    \pgfooget{positions}\pgf@dv@temp
    \edef\pgf@dv@add{\noexpand\pgf@dv@ph{\pgfkeysvalueof{/data point/canvas x}}{\pgfkeysvalueof{/data point/canvas y}}}%
    \expandafter\expandafter\expandafter\def%
    \expandafter\expandafter\expandafter\pgf@dv@temp%
    \expandafter\expandafter\expandafter{\expandafter\pgf@dv@temp\pgf@dv@add}%
    \pgfoolet{positions}\pgf@dv@temp
  }

  \method render(#1) {
    \ifx#1\pgfdvendvisualization
      \pgfoovalueof{handler}
      \pgfplotstreamstart
      \pgfoovalueof{positions}
      \pgfplotstreamend
      \pgfoovalueof{use path}
      \pgfoolet{positions}\pgfutil@empty
    \fi
  }

  \def\pgf@dv@ph#1#2{\pgfplotstreampoint{\pgfqpoint{#1}{#2}}}
}


\endinput
