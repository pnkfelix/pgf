% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Public License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\ProvidesFileRCS $Header: /cvsroot/pgf/pgf/generic/pgf/modules/pgfmoduleoo.code.tex,v 1.2 2008/03/12 21:40:41 tantau Exp $



% Support of object-oriented programming in TeX.


% The oo support works as follows:
%
% The main supported concepts are classes, objects, methods,
% attributes and signal/slots. A class defines a set of methods, which are,
% in the end, just normal TeX macros. Once a class has been created,
% it can be instantiated by calling the \pgfoonew command, resulting
% in a new object. Objects are local to their group. Given an object,
% you can send it a message, resulting in the method code of the
% object's method to be executed. While an object exists, it has a set
% of attributes whose values can change over time. Attributes values
% are not local to TeX groups, rather their life-cycle is the same as
% the object's (which, however, is local to the group in which the
% object was declared).
%
% The implementation is as follows: There is an ID counter that is
% increased each time an object is created. This counter is local to
% the group, which means that when a group ends the counter will
% revert to the previous value, allowing objects to the reused in
% subsequent groups.
%
% A method is just a normal \TeX macro, but to call it you write
% \objecthandle.methodname(parameters). The \objecthandle is a macro
% that is created when you say \pgfoonew. The special object
% \pgfoothis is the current object.
%
% Attributes are stored globally in internal TeX macros whose name is
% composed of the object number and the attribute name.
%
% A signal must first be initialized. Then it can be emitted. Methods
% of objects (called slots in this case) can tune in to signals,
% in this case whenever the signal is raised, a method of the object is
% invoked.



% Declares a class
%
% #1 = class name
% #2 = methods
%
% Description:
%
% This command declares a class for futurue use. Inside #2, the macro
% \method can be used to declare a method. The \method macro takes a
% method name, parameters (methods are normal TeX macros, after all)
% and body.

\long\def\pgfooclass#1#2{%
  \def\pgfoo@classname{#1}%
  \let\pgfoo@origmethod=\method%
  \let\pgfoo@origmethodlet=\methodlet%
  \let\method=\pgfoo@declaremethod%
  #2%
  % Special listen to method:
  \expandafter\let\csname pgfooY\pgfoo@classname.connect signal and slot\endcsname\pgfoo@connect@%
  \expandafter\let\csname pgfooY\pgfoo@classname.connect\endcsname\pgfoo@connect%
  \let\method=\pgfoo@origmethod%
}



% Declare a method
%
% Description:
%
% Defines a method. To use/invoke this method for an object \object,
% you write \object.methodname(parameters). This will cause the method
% body to be invoked with the argument "(parameters)".
%
% To define the method \method should be directly followed by the
% method name and, then, by (, followed by a parameter pattern,
% followed by ), followed by the message body. Spaces are allowed only
% after "\method" and after the closing ).
%
% Example:
%
% \pgfooclass{MyPlot}{
%
%   \method MyPlot() {
%     \pgfooset{x}{0}
%     \pgfooset{y}{0}
%   }
%
%   \method getX(#1) {
%     \pgfooget{x}{#1}
%   }
%
%   \method setPoint(#1,#2) {
%     \pgfooset{x}{#1}
%     \pgfooset{y}{#2}
%   }
% }

\def\pgfoo@declaremethod#1(#2)#3{%
  \expandafter\long\expandafter\def\csname pgfooY\pgfoo@classname.#1\endcsname(#2){#3}%
}



\newcount\pgfoo@objectcount
\newcount\pgfoothis@count

% The attribute value method
%
% #1 = attr
%
% This method inserts the current value of the given attribute for the
% current object.

\def\pgfoovalueof#1{%
  \csname pgfooX\the\pgfoothis@count #1\endcsname%
}


% The attribute get method
%
% #1 = attr
% #2 = macro
%
% This method makes the macro equal to the current value of the
% attribute for the current object.

\def\pgfooget#1#2{%
  \expandafter\let\expandafter#2\csname pgfooX\the\pgfoothis@count #1\endcsname%
}


% The attribute set method
%
% #1 = attr
% #2 = value
%
% This method sets the given attribute for the current object to the
% given value.

\long\def\pgfooset#1#2{%
  \expandafter\gdef\csname pgfooX\the\pgfoothis@count #1\endcsname{#2}%
}


% The attribute set method (expanded version)
%
% #1 = attr
% #2 = value
%
% This method sets the given attribute for the current object to the
% expanded version of the given value.

\long\def\pgfooeset#1#2{%
  \expandafter\xdef\csname pgfooX\the\pgfoothis@count #1\endcsname{#2}%
}


% The attribute let method
%
% #1 = attr
% #2 = value
%
% This method sets the given attribute for the current object to the
% given value.

\def\pgfoolet#1#2{%
  \expandafter\global\expandafter\let\csname pgfooX\the\pgfoothis@count #1\endcsname#2%
}



% Instantiate an object
%
% Syntax:
%
% \pgfoonew [\<objectname>=]new <class name>(<constructor parameters)
%
% Description:
%
% Creates an object. After the obejct has been created, the method
% called <class name> (the constructor) is invoked. If the
% \<objectname>= part is present, the macro is assigned to the newly
% created object.

\def\pgfoonew{\pgfutil@ifnextchar n{\pgfoo@new\pgfoo@dummy=}{\pgfoo@new}}
\def\pgfoo@new#1=new #2(#3){%
  \expandafter\ifx\csname pgfooY#2.connect\endcsname\relax%
    \PackageError{pgfoo}{Unknown class '#2'}{}%
  \else%
    \advance\pgfoo@objectcount by 1\relax%
    \edef\pgfoo@temp@obj{\noexpand\pgfoo@caller{\the\pgfoo@objectcount}}%
    \expandafter\gdef\csname pgfooX\the\pgfoo@objectcount class\endcsname{#2}%
    \pgfoo@temp@obj.#2(#3)%
    \let#1\pgfoo@temp@obj%
  \fi%
}

\def\pgfoo@caller#1.#2(#3){%
  \def\pgf@marshal{%
    \pgfoothis@count=#1\relax%
    \csname pgfooY\csname pgfooX\the\pgfoothis@count class\endcsname.#2\endcsname(#3)%
  }%
  \expandafter\pgf@marshal\expandafter\pgfoothis@count\the\pgfoothis@count\relax%
}
\let\pgfoo@orig@caller=\pgfoo@caller

% The special "this" object

\def\pgfoothis.#1(#2){%
  \csname pgfooY\csname pgfooX\the\pgfoothis@count class\endcsname.#1\endcsname(#2)%
}




% Initialize a signal
%
% #1 = signal name
%
% Description:
%
% Initalizes a signal so that objects can start listening to it. The
% event is local to the current TeX group. If the does already exist,
% it will be "cleared".

\def\pgfoonewsignal#1{%
  \expandafter\let\csname pgfooZ#1\endcsname\pgfutil@empty%
}




% Connect a slot (method) of an object to a signal.
%
% #1 = signal
% #2 = slot
%
% Description:
%
% This special method is defined for every class. After this method
% has been called, the object will listen to #2. Whenever the event #2
% is occurs (using \pgfooevent), the method named "event" of the
% current object #1 is invoked. The event must previously have been
% initialized using \pgfooinitevent. 

\def\pgfoo@connect@(#1,#2){%
  \expandafter\let\expandafter\pgfoo@e\csname pgfooZ#1\endcsname%
  \ifx\pgfoo@e\relax%
    \PackageError{pgfoo}{Unknown signal '#1'}{}%
  \else%
    \let\pgfoo@caller=\relax% to avoid expansion
    \edef\pgfoo@e{\pgfoo@e\pgfoo@caller{\the\pgfoothis@count}.#2()}
    \let\pgfoo@caller=\pgfoo@orig@caller%
    \expandafter\let\csname pgfooZ#1\endcsname\pgfoo@e%
  \fi%
}

% Connect a slot (method) of an object to a signal of the same name.
%
% #1 = signal and also slot name
%
% Description:
%
% \pgfoothis.connect(foo) is just an abbreviation for
% \pgfoothis.connect signal and slot(foo,foo)

\def\pgfoo@connect(#1){\pgfoo@connect@(#1,#1)}



% Emit a signal
%
% #1 = signal name
%
% Description:
%
% For all objects that are currently listening to the signal, the
% slots are activated.

\def\pgfooemit#1{%
  \csname pgfooZ#1\endcsname%
}





\endinput
