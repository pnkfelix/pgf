\section{Tutorial: A Petri-Net for Hagen}

In this second tutorial we explore the node mechanism of
\tikzname.

Hagen must give a talk tomorrow about his favorite formalism for
distributed systems: Petri nets! Hagen used to give his talks using a
blackboard and everyone seemed to be perfectly concent with
this. Unfortunately, his audience has been spoiled recently with fancy
projector-based presentations and there seems to be a certain amount
of peer pressure that this Petri nets should also be drawn using a
graphic program. One of the professors at his institutes recommends
\tikzname\ for this and Hagen decides to give it a try.


\subsection{Problem Statement}

For his talk, Hagen wishes to create a graphic that explains how
place capacities can be simulated by nets without capacities. The
graphic should look like this, ideally:

\begin{tikzpicture}
  \tikzstyle{place}=[circle,draw=blue!50,fill=blue!20,minimum size=8mm]
  \tikzstyle{transition}=[rectangle,draw=red!50,fill=red!20,minimum size=6mm]
  \tikzstyle{pre}=[<-,shorten <=1pt]
  \tikzstyle{post}=[->,shorten >=1pt]

  \tikzstyle{mark}=[circle,fill,minimum size=1mm,inner sep=0pt]
\end{tikzpicture}

Still missing...


\subsection{Setting up the Environment}

\subsubsection{Setting up the Environment in \LaTeX}

\subsubsection{Setting up the Environment in Plain \TeX}

\subsubsection{Setting up the Environment in Con\TeX t}


\subsection{Nodes}

to be rewritten:

Placing text at a given position is just a special case of a more
general underlying mechanism. When you say |\draw (0,0) node{text};|,
what actually happens is that a rectangular node, anchored at its center, is
put at position $(0,0)$. On top of the rectangular node the text
|text| is drawn. Since no action is specified for the rectangle (like
|draw| or |fill|), the rectangle is actually discarded and only the
text is shown. However, by adding |fill| or |draw|, we can make the
underlying shape visible. Furthermore, we can \emph{change} the
shape using for example |shape=circle| or just |circle|. If we include
the package |pgflibraryshapes| we also get |ellipse|:


\begin{codeexample}[]
\begin{tikzpicture}
  \path (0,0)   node[ellipse,fill=examplefill,draw]
                  (h1) {hello world}
        (0.5,2) node[circle,shade,ball color=examplefill]
                  (h2) {hello world};
  \draw [->,shorten >=2pt] (h1.north) -- (h2.south);
\end{tikzpicture}
\end{codeexample}

As the above example shows, we can add the a name to a node by
putting it in parentheses between |node| and the |{|\meta{text}|}|
(you can also use the |name=| option). This will make \tikzname\ remember your node and all
its anchors. You can then refer to these anchors when specifying
coordinates. The syntax is |(|\meta{node
  name}|.|\meta{anchor}|)|. Currently, and also in the near future, 
\emph{this will not work across pictures since \tikzname\ looses track
  of the positions when it returns control to \TeX.} Magic hackery is
possible for certain drivers, but a portable implementation seems
impossible (just think of a possible \textsc{svg} driver). 

The option |shorten >| causes lines to be shortened by 2pt at the
end. Similarly, |shorten <| can be used to shorten (or even lengthen)
lines at the beginning. This is possible even if no arrow is drawn.

It is not always necessary to specify the anchor. If you do not give
an anchor, \tikzname\ will try to determine a reasonable border anchor by
itself (if \tikzname\ fails to find anything useful, it will use the
center instead). Here is a typical example:

\begin{codeexample}[]
\begin{tikzpicture}
  \begin{scope}[shape=circle,minimum size=1cm,fill=examplefill]
    \tikzstyle{every node}=[draw,fill]
    \node (q_A) at (0,0) {$q_A$};
    \node (q_E) at (6,0) {$q_E$};
    \node (q_1) at (2,0) {$q_1$};
    \node (q_2) at (4,2) {$q_2$};
  \end{scope}
  \draw (q_A) -- (q_1) -- (q_2) -| (q_E);
  \draw[->,shorten >=2pt] (q_A) .. controls +(75:1.4cm) and +(105:1.4cm) .. node[above] {$x$} (q_A);
\end{tikzpicture}
\end{codeexample}

In the example, we used the |\node| command, which is an abbreviation
for |\path node|. 
