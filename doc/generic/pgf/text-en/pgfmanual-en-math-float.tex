% Copyright 2008 by Christian Feuersaenger
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.

\subsection{Extended Accuracy and Floating point operations}

{\small \emph{An extension by Christian Feuers\"anger}}
\vspace{0.4cm}%

\label{pgfmath-floatunit}

\noindent
While the \pgfname\ math parser provides both speed and comfort, it is sometimes necessary to work with higher accuracy than the built-in fixed point arithmetics of \TeX. 

\pgfname\ provides limited floating point number support to implement number printing (see section~\ref{pgfmath-numberprinting}) and some very basic arithmetic operations (mainly for bounding box computations at high accuracy). The floating point unit parses numbers in a text-format. It allows access to numbers of large (or small) magnitude at high accuracy, but it is not designed to provide full expression parsing.

\begin{command}{\pgfmathfloatparsenumber\marg{x}}
	Reads a number of arbitrary magnitude and precision and stores its result into |\pgfmathresult| as floating point number $m \cdot 10^e$ with mantisse and exponent base~$10$.

	The algorithm and the storage format is purely text-based. The number is stored as a triple of flags, a positive mantisse and an exponent, such as
\begin{codeexample}[]
\pgfmathfloatparsenumber{2}
\pgfmathresult
\end{codeexample}
	Please do not rely on the low-level representation here, use |\pgfmathfloattomacro| (and its variants) and |\pgfmathfloatcreate| if you want to work with these components.

	The flags encoded in |\pgfmathresult| are represented as a digit where `$0$' stands for the number $\pm 0\cdot 10^0$, `$1$' stands for a positive sign, `$2$' means a negative sign, `$3$' stands for `not a number', `$4$' means $+\infty$ and `$5$' stands for $-\infty$.

	The mantisse is a normalized real number $m \in \mathbb{R}$, $1 \le m < 10$. It always contains a period and at least one digit after the period. The exponent is an integer.

	Examples:
\begin{codeexample}[]
\pgfmathfloatparsenumber{0}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}

\begin{codeexample}[]
\pgfmathfloatparsenumber{0.2}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}

\begin{codeexample}[]
\pgfmathfloatparsenumber{42}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}

\begin{codeexample}[]
\pgfmathfloatparsenumber{20.5E+2}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}

\begin{codeexample}[]
\pgfmathfloatparsenumber{1e6}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}

\begin{codeexample}[]
\pgfmathfloatparsenumber{5.21513e-11}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}
	The argument \marg{x} may be given in fixed point format or the scientific `e' (or `E') notation. The scientific notation does not necessarily need to be normalised. Its exponent should be limited to the range $-16000 \le e \le +16000$ (the \TeX-integer range).
\end{command}

\begin{command}{\pgfmathfloatqparsenumber\marg{x}}
	The same as |\pgfmathfloatparsenumber|, but does not perform sanity checking.
\end{command}

\begin{command}{\pgfmathfloattofixed{\marg{x}}}
	Converts a number in floating point representation to a fixed point number. It is a counterpart to |\pgfmathfloatparsenumber|. The algorithm is purely text based and defines |\pgfmathresult| as a string sequence which represents the floating point number \marg{x} as a fixed point number (of arbitrary precision).

\begin{codeexample}[]
\pgfmathfloatparsenumber{0.00052}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E
$\to$ 
\pgfmathfloattofixed{\pgfmathresult}
\pgfmathresult
\end{codeexample}

\begin{codeexample}[]
\pgfmathfloatparsenumber{123.456e4}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E
$\to$
\pgfmathfloattofixed{\pgfmathresult}
\pgfmathresult 
\end{codeexample}
\end{command}

\begin{command}{\pgfmathfloattosci\marg{float}}
	Converts a number from low-level floating point representation to scientific format, $1.234e4$.
\end{command}

\begin{command}{\pgfmathfloatcreate{\marg{flags}}{\marg{mantisse}}{\marg{exponent}}}
	Defines |\pgfmathresult| as the floating point number encoded by
	\marg{flags}, \marg{mantisse} and \marg{exponent}.
	
	All arguments are characters and will be expanded using |\edef|.
\begin{codeexample}[]
\pgfmathfloatcreate{1}{1.0}{327}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E
\end{codeexample}
\end{command}

\begin{command}{\pgfmathfloattomacro{\marg{x}}{\marg{flagsmacro}}{\marg{mantissemacro}}{\marg{exponentmacro}}}
	Extracts the flags of a floating point number \marg{x} to \marg{flagsmacro}, the mantisse to \marg{mantissemacro} and the exponent to \marg{exponentmacro}.
\end{command}

\begin{command}{\pgfmathfloattoregisters{\marg{x}}{\marg{flagscount}}{\marg{mantissedimen}}{\marg{exponentcount}}}
	Takes a floating point number \marg{x} as input and writes flags to count
	register \marg{flagscount}, mantisse to dimen register \marg{mantissedimen} and exponent to count
	register \marg{exponentcount}.

	Please note that this method rounds the mantisse to \TeX-precision.
\end{command}

\begin{command}{\pgfmathfloattoregisterstok{\marg{x}}{\marg{flagscount}}{\marg{mantissetoks}}{\marg{exponentcount}}}
	A variant of |\pgfmathfloattoregisters| which writes the mantisse into a token register. It maintains the full input precision.
\end{command}

\begin{command}{\pgfmathfloatgetflags{\marg{x}}{\marg{flagscount}}}
	Extracts the flags of \marg{x} into the count register \marg{flagscount}.
\end{command}

\begin{command}{\pgfmathfloatgetmantisse{\marg{x}}{\marg{mantissedimen}}}
	Extracts the mantisse of \marg{x} into the dimen register \marg{mantissedimen}.
\end{command}
\begin{command}{\pgfmathfloatgetmantissetok{\marg{x}}{\marg{mantissetoks}}}
	Extracts the mantisse of \marg{x} into the token register \marg{mantissetoks}.
\end{command}
\begin{command}{\pgfmathfloatgetexponent{\marg{x}}{\marg{exponentcount}}}
	Extracts the exponent of \marg{x} into the count register \marg{exponentcount}.
\end{command}

\begin{command}{\pgfmathfloatlessthan{\marg{x}}{\marg{y}}}
	Defines |\pgfmathresult| as $1.0$ if $\meta{x} < \meta{y}$, but $0.0$ otherwise. It also sets the global \TeX-boolean |\pgfmathfloatcomparison| accordingly. The arguments \marg{x} and \marg{y} are expected to be numbers which have already been processed by |\pgfmathfloatparsenumber|. Arithmetics is carried out using \TeX-registers for exponent- and mantisse comparison.
\end{command}

\begin{command}{\pgfmathfloatmax{\marg{x}}{\marg{y}}}
	Defines |\pgfmathresult| as the maximum of two floating point numbers \marg{x} and \marg{y}. The arguments \marg{x} and \marg{y} are expected to be numbers which have already been processed by |\pgfmathfloatparsenumber|. Arithmetics is carried out using \TeX-registers for exponent- and mantisse comparison.
\end{command}

\begin{command}{\pgfmathfloatmin{\marg{x}}{\marg{y}}}
	Defines |\pgfmathresult| as the minimum of two floating point numbers \marg{x} and \marg{y}. The arguments \marg{x} and \marg{y} are expected to be numbers which have already been processed by |\pgfmathfloatparsenumber|. Arithmetics is carried out using \TeX-registers for exponent- and mantisse comparison.
\end{command}


\begin{command}{\pgfmathfloatshift{\marg{x}}{\marg{num}}}
	Defines |\pgfmathresult| to be $\meta{x} \cdot 10^{\meta{num}}$. The operation is an arithmetic shift base ten and modifies only the exponent of \marg{x}. The argument \marg{num} is expected to be a (positive or negative) integer.
\end{command}

\begin{command}{\pgfmathfloatadd{\marg{x}}{\marg{y}}}
	Defines |\pgfmathresult| to be $\meta{x} + \meta{y}$ for two floating point numbers, returning another floating point number.

	It invokes the usual math engine on mantisses and employs 8 significant decimal digits for its computation (using |\pgfmathfloattoextentedprecision|).
\end{command}

\begin{command}{\pgfmathfloatsubtract{\marg{x}}{\marg{y}}}
	Defines |\pgfmathresult| to be $\meta{x} - \meta{y}$ for two floating point numbers, returning a floating point number.

	It invokes the usual math engine on mantisses and employs 8 significant decimal digits for its computation (using |\pgfmathfloattoextentedprecision|).
\end{command}

\begin{command}{\pgfmathfloatmultiply{\marg{x}}{\marg{y}}}
	Defines |\pgfmathresult| to be $x \cdot y$ for two floating point numbers, returning a floating point number.
	
	It invokes the usual math engine on mantisses.
\end{command}
\begin{command}{\pgfmathfloatmultiplyfixed\marg{float}\marg{fixed}}
	Defines |\pgfmathresult| to be $\meta{float} \cdot \meta{fixed}$ where \meta{float} is a floating point number and \meta{fixed} is a fixed point number. The computation is performed in floating point arithmetics, that means we compute $m \cdot \meta{fixed}$ and renormalize the result where $m$ is the mantisse of \meta{float}.

	This operation renormalizes \meta{float} with |\pgfmathfloattoextentedprecision| before the operation, that means it is intended for relatively small arguments of \meta{fixed}. The result is a floating point number.
\end{command}

\begin{command}{\pgfmathfloatdivide{\marg{x}}{\marg{y}}}
	Defines |\pgfmathresult| to be $x / y$ for two floating point numbers, returning a floating point number.
	
	It invokes the usual math engine on mantisses.
\end{command}

\begin{command}{\pgfmathfloatsqrt{\marg{x}}}
	Defines |\pgfmathresult| to be $\sqrt x$ for a floating point $x$ and returns the result as floating point number.
	
	It invokes the usual math engine on mantisses. It has a relative precision of about $10^{-5}$.
\end{command}
\begin{command}{\pgfmathfloatabs{\marg{x}}}
	Defines |\pgfmathresult| to be $\lvert x\rvert $ for a floating point number $x$ and returns the result as floating point number.
\end{command}

\begin{command}{\pgfmathfloatabserror\marg{x}\marg{y}}
	Defines |\pgfmathresult| to be the absolute error between two floating point numbers $x$ and $y$, $\lvert x - y\rvert $ and returns the result as floating point number.
\end{command}

\begin{command}{\pgfmathfloatrelerror\marg{x}\marg{y}}
	Defines |\pgfmathresult| to be the relative error between two floating point numbers $x$ and $y$, $\lvert x - y\rvert / \lvert y \rvert $ and returns the result as floating point number.
\end{command}
\begin{command}{\pgfmathfloattoextentedprecision{\marg{x}}}
Renormalizes \marg{x} to extended precision mantisse, meaning
$100 \le m < 1000$ instead of $1 \le m < 10$.

The `extended precision' means we have higher accuracy when we apply pgfmath operations to mantisses.

The input argument is expected to be a normalized floating point number; the output argument is a non-normalized floating point number (well, normalized to extended precision).

The operation is supposed to be very fast.
\end{command}
\begin{command}{\pgfmathfloatint\marg{x}}
Returns the integer part of the floating point number \marg{x}, by truncating any digits after the period. This methods is applied to the absolute value $\rvert x \lvert$, so negative numbers are treated in the same way as positive ones.

The result is returned as floating point number as well.
\end{command}

\begin{command}{\pgfmathfloatsetextprecision\marg{shift}}
	Sets the precision used inside of |\pgfmathfloattoextentedprecision| to \marg{shift}.

	The different choices are
	
	\begin{tabular}{llrll}
	0 & normalization to &    $0$ & $\le m < 1$ 	& (disable extended precision)\\
	1 & normalization to &   $10$ & $\le m < 100$	\\
	2 & normalization to & 	$100$ & $\le m < 1000$	& (default of |\pgfmathfloattoextentedprecision|)\\
	3 & normalization to & $1000$ & $\le m < 10000$	\\
	\end{tabular}
\end{command}

\begin{command}{\pgfmathroundto{\marg{x}}}
	Rounds a fixed point number to prescribed precision and writes the result to |\pgfmathresult|.

	The desired precision can be configured with |/pgf/number format/precision|, see section~\ref{pgfmath-numberprinting}. This section does also contain application examples.
	
	Any trailing zeros after the period are discarded. The algorithm is purely text based and allows to deal with precisions beyond \TeX's fixed point support.

	As a side effect, the global boolean |\ifpgfmathfloatroundhasperiod| will be set to true if and only if the resulting mantisse has a period. Furthermore, |\ifpgfmathfloatroundmayneedrenormalize| will be set to true if and only if the rounding result's floating point representation would have a larger exponent than \marg{x}. 
\begin{codeexample}[]
\pgfmathroundto{1}
\pgfmathresult
\end{codeexample}
\begin{codeexample}[]
\pgfmathroundto{4.685}
\pgfmathresult
\end{codeexample}
\begin{codeexample}[]
\pgfmathroundto{19999.9996}
\pgfmathresult
\end{codeexample}
\end{command}

\begin{command}{\pgfmathroundtozerofill{\marg{x}}}
	A variant of |\pgfmathroundto| which always uses a fixed number of digits behind the period. It fills missing digits with zeros.
\begin{codeexample}[]
\pgfmathroundtozerofill{1}
\pgfmathresult
\end{codeexample}
\begin{codeexample}[]
\pgfmathroundto{4.685}
\pgfmathresult
\end{codeexample}
\begin{codeexample}[]
\pgfmathroundtozerofill{19999.9996}
\pgfmathresult
\end{codeexample}
\end{command}

\begin{command}{\pgfmathfloatround{\marg{x}}}
	Rounds a normalized floating point number to a prescribed precision and writes the result to |\pgfmathresult|.

	The desired precision can be configured with |/pgf/number format/precision|, see section~\ref{pgfmath-numberprinting}. 
	
	This method employs |\pgfmathroundto| to round the mantisse and applies renormalizations if necessary.

	As a side effect, the global boolean |\ifpgfmathfloatroundhasperiod| will be set to true if and only if the resulting mantisse has a period.
\begin{codeexample}[]
\pgfmathfloatparsenumber{52.5864}
\pgfmathfloatround{\pgfmathresult}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}
\begin{codeexample}[]
\pgfmathfloatparsenumber{9.995}
\pgfmathfloatround{\pgfmathresult}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}
\end{command}

\begin{command}{\pgfmathfloatroundzerofill{\marg{x}}}
	A variant of |\pgfmathfloatround| produces always the same number of digits after the period (it includes zeros if necessary).
\begin{codeexample}[]
\pgfmathfloatparsenumber{52.5864}
\pgfmathfloatroundzerofill{\pgfmathresult}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}
\begin{codeexample}[]
\pgfmathfloatparsenumber{9.995}
\pgfmathfloatroundzerofill{\pgfmathresult}
\pgfmathfloattomacro{\pgfmathresult}{\F}{\M}{\E}
Flags: \F; Mantisse \M; Exponent \E.
\end{codeexample}
\end{command}

\begin{command}{\pgfmathlog{\marg{x}}}
	Defines |\pgfmathresult| to be the natural logarithm of \marg{x}, $\ln(\meta{x})$. This method is logically the same as |\pgfmathln|, but it applies floating point arithmetics to read number \marg{x} and employs the logarithm identity 
		\[ \ln(m \cdot 10^e) = \ln(m) + e \cdot \ln(10) \]
	to get the result. The factor $\ln(10)$ is a constant, so only $\ln(m)$ with $1 \le m < 10$ needs to be computed. This is done using standard pgf math operations.

	Please note that \marg{x} needs to be a number, expression parsing is not possible here.

	If \marg{x} is \emph{not} a bounded positive real number (for example $\meta{x} \le 0$), |\pgfmathresult| will be \emph{empty}, no error message will be generated.
\begin{codeexample}[]
\pgfmathlog{1.452e-7}
\pgfmathresult
\end{codeexample}
\begin{codeexample}[]
\pgfmathlog{6.426e+8}
\pgfmathresult
\end{codeexample}
\end{command}

%--------------------------------------------------
% \subsubsection{Implementation details: Accessing flags, mantisse and exponent}
% Floating point representations can be read using some private macros which are only available if `|@|' is a letter (that means inside of package/module implementations).
% 
% \begin{command}{\pgfmathfloat@decompose\marg{x}\relax\marg{f}\marg{m}\marg{e}}
% 	Assigns floating point flags of number \marg{x} to integer register \marg{f}, the mantisse to the dimen register \marg{m} and the exponent to integer register \marg{e}.
% 
% 	The input argument \marg{x} needs to be fully expanded and must not be enclosed by braces.
% \end{command}
% 
% \begin{command}{\pgfmathfloat@decompose@tok\marg{x}\relax\marg{f}\marg{m}\marg{e}}
% 	Works in the same way as |\pgfmathfloat@decompose|, but assumes that \marg{m} is a token register (i.e. reads the mantisse as a character sequence).
% \end{command}
% 
% \begin{command}{\pgfmathfloat@decompose@F\marg{x}\relax\marg{f}}
% 	Reads only flags into integer register \marg{f}.
% \end{command}
% \begin{command}{\pgfmathfloat@decompose@M\marg{x}\relax\marg{m}}
% 	Reads only the mantisse into dimen register \marg{m}.
% \end{command}
% \begin{command}{\pgfmathfloat@decompose@Mtok\marg{x}\relax\marg{m}}
% 	Reads only the mantisse into token register \marg{m}.
% \end{command}
% \begin{command}{\pgfmathfloat@decompose@Mtok\marg{x}\relax\marg{e}}
% 	Reads only the exponent into integer register \marg{e}.
% \end{command}
%-------------------------------------------------- 
