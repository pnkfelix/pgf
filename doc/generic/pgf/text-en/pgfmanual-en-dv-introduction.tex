% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Introduction to Data Visualization}


\emph{Data visualization} is the process of converting \emph{data
  points,} which typically consist of multiple numerical values, into
a graphical representation. Examples include the well-known function
plots, but pie charts, bar diagrams, box plots, or vector fields are
also examples of data visualizations.

The data visualization subsystem of \pgfname\ takes a general, open
approach to data visualization. Like everything else in \pgfname,
there is a powerful, but not-so-easy-to-use basic layer in the data
visualization system and a less flexible, but much simpler-to-use
frontend layer. The present section gives a quick overview of the
basic ideas behind the data visualization system are introduced which
are important for both layers.


\subsection{Concept: Data Points}

The most important input for a data visualization is always raw
data. This data is typically present in different formats and the data
visualization subsystem provides methods for reading such formats and
also for defining new input formats. However, independently of the
input format, we may ask what kind of data the data visualization
subsystem should be able to process. For two-dimensional plots we
need lists of pairs of real numbers. For a bar plot we usually need a
list of numbers, possibly together with some colors and labels. For a
surface plot we need a matrix of triples of real numbers. For a vector
field we need even more complex data.

The data visualization subsystem makes no assumption whatsoever as to
the kind of data that is being processed. Instead, the whole
``rendering pipeline'' is centered around a central concept called the
\emph{data point}. Conceptually, a data point is an aribitrarily
complex record that represents one piece of data that should be
visualized. Data points are \emph{not} just coordinates in the plane
or the numerical values that need to be visualized. Rather, they
represent the basic units of the data that needs to be visualized.

Consider the following example: In an experiment we drive a car along
a road and have different measurement instruments installed. We
measure the position of the car, the time, the speed, the direction
the car is heading, the acceleration, and perhaps some further
values. A data point would now consist of a record consisting of a
timestamp together with the current position of the car (presumably
two or three numbers), the speed vector (another two or three
numbers), the acceleration (another two or three numbers), and perhaps
the label text of the current experiment. 

Data points should be ``information rich.'' They might even contain
more information than what will actually be visualized. It is the job
of the rendering pipeline to pick out the information relevant to one
particular data visualization -- another visualization of the same
data might pick different aspects of the data points, thereby
hopefully allowing new insights into the data.

Technically, there is no special data structure for data
points. Rather, when a special macro called |\pgfdatapoint| is called,
the ``totality'' of all currently set keys and macros in the current
scope forms the data point. This is both a very general approach and
quite fast since no extra data structures need to be created. However,
a number of classes in the visualization pipeline (see below) assume
that only keys in the \pgfname\ keys tree starting with |/data point/|
are used to store information about data points. 


\subsection{Concept: Visualization Pipeline}

The \emph{visualization pipeline} is a series of actions that are
performed on the to be visualized data. As was just described, the
data is presented to the visualization pipeline in the form of a long
stream of quite complex data points. The visualization pipeline makes
two passes over this stream of data points. During the first pass
information is gathered about the data points such as minimal and
maximal values, which can be useful for automatic fitting of the data
into a given area. In the main pass over the data the data points are
actually visualized, for instance in the form of lines or points.

Like for data points, the visualized pipeline makes no assumptions as
to what kind of visualization is desired. Indeed, one could even use
it to produce a plain-text table. This flexibility is achieved by
extensive use of objects and signals: When a data visualization
starts, a number of signals (see Section~\ref{section-signals} for an
introduction to signals) are initialized. Then, numerous
``visualization objects'' are created that listen to these
signals. These objects are all involved in processing the data
points. For instance, the job of an |attribute mapper| object is to
map one attribute of a data point, such as a car's velocity, to
another, such as the $y$-axis of a plot. For each data point the
different signals are raised in a certain order and the different
visualization objects now have a chance of preparing the data point
for the actual visualization. Continuing the above example, there
might be a second |attribute mapper| that takes the computed
$y$-position and applies a logarithm to it, because a log-plot was
requested. Then another mapper, this time a |polar mapper| might be
used to map everything to polar coordinates. Following this, a
|plot mark visualizer| might actually draw something at the computed
position.

The whole idea behind the rendering pipeline is that new kinds of data
visualizations can be implemented, ideally, just by adding one or two
new objects to the visualization pipeline. Furthermore, different
kinds of plots can be combined in novel ways in this manner, which is
usually very hard to do. For instance, the visualization pipeline
makes it easy to create, say, polar-semilog-box-plots. At first sight,
such new kinds of plots may seem superfluous, but data visualization
is all about gaining insights into the data from as many different
angles as possible.

Naturally, creating new classes and objects for the rendering pipeline
is not trivial, so most users will just use the existing classes,
which should, thus, be as flexible as possible. But even when one only
wishes to use existing classes, it is still tricky to setup the
pipeline correctly since the ordering is obviously important and since
tricky things like axes and ticks need to be configured and taken care
of. For this reason, there the frontend libraries provide
preconfigured rendering pipelines, so that one can simply say that a
data visualization should look like a |schoolbook plot|, which selects
a certain visualization pipeline appropriate for this kind of
plot. Once must still configure such a plot (choose styles and themes
and also specify which attributes of a data point should be used), but
on the whole the plot is quite simple to specify.





\subsection{Testing}

The following is purely for test purposes only and will be removed in
future version.

%\endinput

% The following is just testing.

A candle-stick plot:

\pgfdeclaredataformat{dax line}{}{}{dax: #1 #2 #3 #4}{
  \pgfkeyssetvalue{/data point/dax/low}{#1}
  \pgfkeyssetvalue{/data point/dax/high}{#2}
  \pgfkeyssetvalue{/data point/dax/entry}{#3}
  \pgfkeyssetvalue{/data point/dax/exit}{#4}
  \pgfdatapoint
}{}{}

\def\daxline#1 #2 #3 #4 {
  \pgfkeyssetvalue{/data point/dax/low}{#1}
  \pgfkeyssetvalue{/data point/dax/high}{#2}
  \pgfkeyssetvalue{/data point/dax/entry}{#3}
  \pgfkeyssetvalue{/data point/dax/exit}{#4}
  \pgfdatapoint
}

\begin{tikzpicture}
  \pgfnewdatavisualization

  \pgfoonew \obj=new count up(day)
  \obj.default connects()
  
  \pgfoonew \obj=new line transformer(day,\pgfqpoint{3mm}{0mm})
  \obj.default connects()
  \pgfoonew \obj=new line transformer(y,\pgfqpoint{1mm}{1cm})
  \obj.default connects()

  \pgfoonew \obj=new attribute mapper(dax,0,100,y,0,1,)
  \obj.default connects()
  \pgfoonew \obj=new candle stick visualizer(dax)
  \obj.default connects()

  \pgfoonew \dayinterval=new interval(,)
  \dayinterval.default connects()
  \dayinterval.set min adjust relative(-.1)
  \dayinterval.set max adjust relative(.1)
  \pgfoonew \daybounder=new attribute bounder(day,\dayinterval)
  \daybounder.default connects()

  \pgfoonew \daxinterval=new interval(,)
  \daxinterval.default connects()
  \daxinterval.set min adjust relative(-.1)
  \daxinterval.set max adjust relative(.1)
  \pgfoonew \daxbounder=new attribute bounder(dax,\daxinterval)
  \daxbounder.default connects()
  
  \pgfoonew \dayaxis=new straight axis(day,\dayinterval)
  \dayaxis.default connects()
  \pgfoonew \daxaxis=new straight axis(dax,\daxinterval)
  \daxaxis.default connects()

  \pgfdataset
    [format=space separated columns,
     column 1=dax/low,
     column 2=dax/high,
     column 3=dax/entry,
     column 4=dax/exit]
   \data
     {
      % today
      2000 2300 2100 2200 
      2000 2350 2200 2500
      2200 2300 2250 2260 
      1800 2260 2260 1900 
      2000 2300 2100 2200
    }
    
    \data[format=comma separated columns]
    {
      % yesterday
      2000, 2350, 2200, 2250 
      2200, 2300, 2250, 2260 
    }
    %\data[source=data,format=comma separated columns]
  \relax

  \pgfkeys{/data point/dax/low/.initial=,
    /data point/dax/high/.initial=,
    /data point/dax/entry/.initial=,
    /data point/dax/exit/.initial=}
    
  \pgfdataset{
    \data[format=key value pairs]{
      dax/low=1800, dax/high=2200, %
      dax/entry=1800, dax/exit=1850
    }
  }
\end{tikzpicture}


A simple plot

\def\dataline#1 #2 #3 #4 #5 #6 #7 #8 {%
  \pgfkeyssetvalue{/data point/a}{#1}
  \pgfkeyssetvalue{/data point/b}{#2}
  \pgfkeyssetvalue{/data point/c}{#3}
  \pgfkeyssetvalue{/data point/d}{#4}
  \pgfkeyssetvalue{/data point/e}{#5}
  \pgfkeyssetvalue{/data point/f}{#6}
  \pgfkeyssetvalue{/data point/g}{#7}
  \pgfkeyssetvalue{/data point/h}{#8}
  \pgfdatapoint
}

\begin{tikzpicture}
  \pgfnewdatavisualization

  %\pgfoonew new attribute mapper(a,0,1,x,0,1,)
  %\pgfoonew new attribute mapper(b,0,1,y,0,1,)
  \pgfoonew \obj=new count up(y)
  \obj.default connects()
  
  \pgfoonew \obj=new sum(a)
  \obj.default connects()
  
  \pgfkeyssetvalue{/data point/x}{\pgfkeysvalueof{/data point/a/sum}}
  
  \pgfoonew \transformer=new line transformer(x,\pgfpointxy{.1}{.05})
  \transformer.default connects()
  
  \pgfoonew \transformer=new line transformer(y,\pgfpointxy{-0.1}{1})
  \transformer.default connects()

  \pgfoonew \visualizer=new plot handler visualizer(\pgfplothandlerlineto)
  \visualizer.default connects()
  \visualizer.set use path(\color{red}\pgfusepath{stroke})
  \pgfoonew \visualizer=new plot mark visualizer(*)
  \visualizer.default connects()
  
  \pgfoonew \interval=new interval(0,)
  \interval.default connects()
  \interval.set min adjust relative(-.1)
  \interval.set max adjust relative(.1)
  \pgfoonew \abounder=new attribute bounder(x,\interval)
  \abounder.default connects()
  
  \pgfoonew \yinterval=new interval(,)
  \yinterval.set min adjust relative(-.1)
  \yinterval.set max adjust relative(.1)
  \yinterval.default connects()
  
  \pgfoonew \bbounder=new attribute bounder(y,\yinterval)
  \bbounder.default connects()
  
  \pgfoonew \pinterval=new interval(,)
  \pinterval.default connects()
  \pgfoonew \pbounder=new attribute bounder(angle,\pinterval)
  \pbounder.default connects()

  \pgfoonew \rinterval=new interval(,)
  \rinterval.default connects()
  \pgfoonew \rbounder=new attribute bounder(b,\rinterval)
  \rbounder.default connects()
  
  \pgfoonew \axis=new straight axis(x,\interval)
  \axis.default connects()
  \pgfoonew \bxis=new straight axis(y,\yinterval)
  \bxis.default connects()

  \pgfdataset{
    \data[format=TeX code]
  {
    \dataline 10.0	8.04	10.0	9.14	10.0	7.46	8.0	6.58 
    \dataline 8.0	6.95	8.0	8.14	8.0	6.77	8.0	5.76 
    \dataline 13.0	7.58	13.0	8.74	13.0	12.74	8.0	7.71 
    \dataline 9.0	8.81	9.0	8.77	9.0	7.11	8.0	8.84 
    \dataline 11.0	8.33	11.0	9.26	11.0	7.81	8.0	8.47 
    \dataline 14.0	9.96	14.0	8.10	14.0	8.84	8.0	7.04 
    {\dataline 6.0	7.24	6.0	6.13	6.0	6.08	8.0	5.25 }
    \dataline 4.0	4.26	4.0	3.10	4.0	5.39	19.0	12.50 
    \dataline 12.0	10.84	12.0	9.13	12.0	8.15	8.0	5.56 
    {\pgfkeyssetvalue{/data point/name}{yesterday} \dataline 7.0	4.82	7.0	7.26	7.0	6.42	8.0	7.91 }
    {\pgfkeyssetvalue{/data point/name}{today} \dataline 5.0	5.68	5.0	4.74	5.0	5.73	8.0    6.89 }
  }}

  \draw (yesterday) -- (today);
  \pgfkeyssetvalue{/data point/tick lower length}{4pt}
  \pgfkeyssetvalue{/data point/tick higher length}{4pt}

  \begin{scope}[->,thick]
     {
       \bbounder.goto min()
       \pgfkeyssetvalue{/data point/y}{0}
       \axis.visualize()
       % Grid lines
       \begin{scope}[-,thin,black!50]
         \bbounder.goto min()
         \pgfkeysgetvalue{/data point/y}{\mymin}
         \bbounder.goto max()
         \pgfkeysgetvalue{/data point/y}{\mymax}
         \foreach \yval in {\mymin,...,\mymax}
         {
           \pgfkeyssetvalue{/data point/y}{\yval}
           \axis.visualize()
           \begin{scope}[thick,black]
             \axis.visualize as tick()
           \end{scope}
         }
       \end{scope}
     }
    {
      \abounder.goto min()
      \bxis.visualize()
      % Grid lines
      \begin{scope}[-,thin,black!50]
        \abounder.goto min()
        \pgfkeysgetvalue{/data point/x}{\mymin}
        \abounder.goto max()
        \pgfkeysgetvalue{/data point/x}{\mymax}
        \foreach \xval in {0,10,...,\mymax}
        {
          \pgfkeyssetvalue{/data point/x}{\xval}
          \bxis.visualize()
            \begin{scope}[thick,black]
              \bxis.visualize as tick()
            \end{scope}

            \pgfkeyssetvalue{/data point/tick lower length}{0pt}
            \pgfkeyssetvalue{/data point/tick higher length}{3pt}
          \pgfmathparse{\xval+9}
          \let\temp=\pgfmathresult
          \foreach \xvala in {\xval,...,\temp}
          {
            \pgfkeyssetvalue{/data point/x}{\xvala}
            \bxis.visualize as tick()
          }
        }
      \end{scope}
    }
  \end{scope}
  

\end{tikzpicture}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pgfmanual"
%%% End: 
