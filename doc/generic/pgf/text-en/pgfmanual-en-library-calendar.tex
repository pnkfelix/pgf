% Copyright 2006 by Till Tantau
%
% This file may be distributed and/or modified
%
% 1. under the LaTeX Project Public License and/or
% 2. under the GNU Free Documentation License.
%
% See the file doc/generic/pgf/licenses/LICENSE for more details.


\section{Calendar Library}

\label{section-calender-snakes}

\begin{pgflibrary}{calendar}
  The library defines the |\calendar| command, which can be used to
  typeset calendars. The command relies on the |\pgfcalendar| command
  from the |pgfcalendar| package, which is loaded automatically.

  The |\calendar| command is quite configurable, allowing you to
  produce all kinds of different calendars.
\end{pgflibrary}


\subsection{Calendar Command}

The core command for creating calendars in \tikzname\ is the
|\calendar| command. It is available only inside |{tikzpicture}|
environments (similar to, say, the |\draw| command). 

\begin{command}{\calendar \meta{calendar specification}|;|}
  The syntax for this command is similar to commands like |\node| or
  |\matrix|. However, it has its complete own parser and only those
  commands described in the following will be recognized, nothing
  else. Note, furthermore, that a \meta{calendar specification} is not
  a path specification, indeed, no path is created for the calendar.

  \medskip
  \textbf{The specification syntax.}
  The \meta{calendar specification} must be a sequence of
  elements, each of which has one of the following structures:
  \begin{itemize}
  \item |[|\meta{options}|]|

    You provide \meta{options} in square brackets as
    in |[red,draw=none]|. These \meta{options} can be any \tikzname\ 
    option and they apply to the whole calendar. You can provide this
    element multiple times, the effect accumulates.
  \item |(|\meta{name}|)|

    This has the same effect as saying |[name=|\meta{name}|]|. The
    effect of providing a \meta{name} is explained later. Note
    alreadys that \emph{a calendar is not a node} and the \meta{name}
    is \emph{not the name of a node}.
  \item |at (|\meta{coordinate}|)|

    This has the same effect as saying |[at=(|\meta{coordinate}|)]|.
  \item |if (|\meta{date condition}|)| \meta{options or
      commands}\opt{|else|\meta{else options or commands}}

    The effect of such an |if| is explained later.
  \end{itemize}

  At the beginning of every calendar, the following style is used:
  \begin{itemize}
  \itemstyle{every calendar} This style is empty be default.
  \end{itemize}
  
  \medskip
  \textbf{The date range.}
  The overall effect of the |\calendar| command is to execute code for
  each day   of a range of dates. This range of dates is set using the
  following option:
  \begin{itemize}
    \itemoption{dates}|=|\meta{start date}| to |\meta{end date} This
    option specifies the date range. Both the start and end date are
    specified as described on page~\pageref{calendar-date-format}. In
    short: You can provide ISO-format type dates like |2006-01-02|, you
    can replace the day of month by |last| to refer to the last day of a
    month (so |2006-02-last| is the same as |2006-02-28|), and you can
    add a plus sign followed by a number to specify an offset (so
    |2006-01-01+-1| is the same as |2005-12-31|).
  \end{itemize}
  For each date in the given range the code |\tikzdaycode| is
  executed. By default, this code simply produces a node whose text is
  set to the day of month. However, unless further action is taken,
  this will cause all days of a calendar to be put on top of each
  other! For this, you can either use predefined arrangements like
  |day list downward| or |week list| or you can define an arrangement
  yourself. Since defining an arrangement is a bit tricky, it is
  explained only later on. For the time being, let us use a predefined
  arrangement to produce our first calendar:

\begin{codeexample}[]
\tikz \calendar[dates=2000-01-01 to 2000-01-31,week list];  
\end{codeexample}

  \medskip
  \textbf{Changing the spacing.}
  In the above calendar, the spacing between the days is determined by
  the numerous options. Most arrangement do not use all of these
  options, but only those that apply naturally.
  \begin{itemize}
    \itemoption{day xshift}|=|\meta{dimension} specifies the
    horizontal shift between days. This is not the gap between days,
    but the shift between the anchors of their nodes. The default is
    |3.5ex|. 
\begin{codeexample}[]
\tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,xshift=3ex];  
\end{codeexample}
    \itemoption{day yshift}|=|\meta{dimension} specifies the
    vertical shift between days. Again, this is the shift between the
    anchors of their nodes. The default is |3ex|. 
\begin{codeexample}[]
\tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,yshift=2ex];  
\end{codeexample}
    \itemoption{month xshift}|=|\meta{dimension} specifies an
    additional  horizontal shift between different months.
    \itemoption{month yshift}|=|\meta{dimension} specifies an
    additional  vertical shift between different months. 
\begin{codeexample}[]
\tiny
\tikz \calendar[dates=2000-01-01 to 2000-02-last,week list,
                month yshift=0pt];  
\end{codeexample}
\begin{codeexample}[]
\tiny
\tikz \calendar[dates=2000-01-01 to 2000-02-last,week list,
                month yshift=1cm];  
\end{codeexample}
  \end{itemize}

  \medskip
  \textbf{Changing the position of the calendar.}
  The calendar is placed in such a way that, normally, the anchor of
  the first day label is at the origin. This can be changed by using
  the |at| option. When you say |at={(1,1)}|, this anchor of the first
  day will lie at coordinate $(1,1)$.

  In general, arrangements will not always place the anchor of the
  first day at the origin. Sometimes, additional spacing rules get in
  the way. There are different ways of addressing this problem: First,
  you can just ignore it. Since calendars are often placed in their own
  |{tikzpicture}| and since their size if computed automatically, the
  exact position of the origin often does not matter at all. Second,
  you can put the calendar inside a node as in
  |...node {\tikz \calendar...}|. This allows you to position the node
  in the normal ways using the node's anchors. Third, you can be very
  clever and use a single-cell matrix. The advantage is that a matrix
  allows you to provide any anchor of any node inside the matrix as an
  anchor for the whole matrix. For example, the following calendar is
  placed in such a way the center of 2000-01-20 lies on the position
  $(2,2)$:
\begin{codeexample}[]
\begin{tikzpicture}    
  \draw[help lines] (0,0) grid (3,2);
  \matrix [anchor=cal-2000-01-20.center]
  { \calendar[dates=2000-01-01 to 2000-01-31,week list]; \\ };
\end{tikzpicture}
\end{codeexample}
  Unfortunately, the matrix-base positions, which is the cleanest way,
  isnot as portable as the other approaches (it currently does not
  work with the \textsc{svg} backend for instance). 

  \medskip
  \textbf{Changing the appearance of days.}
  As mentioned before, each day in the above calendar is produced by
  an execution of the |\tikzdaycode|. Each time this code is executed,
  the coordinate system will have been setup appropriately to place
  the day of the month correctly. You can change both the code and its
  appearance using the following options.
  \begin{itemize}
    \itemoption{day code}|=|\meta{code}
    This option allows you to change the code that is executed for
    each day. The default is to create a node with an appropriate
    name, but you can change this:
\begin{codeexample}[]
\tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,
                day code={\fill[blue] (0,0) cirlce (2pt);}];  
\end{codeexample}
    The default code is the following:
\begin{codeexample}[code only]
\node[name=\pgfcalendarsuggestedname,every day]{\tikzdaytext};
\end{codeexample}
    The first part causes the day nodes to be accessible via the
    following names: If \meta{name} is the name given to the calendar
    via a |name=| option or via the specification element
    |(|\meta{name}|)|, then |\pgfcalendarsuggestedname| will expand to
    \meta{name}|-|\meta{date}, where \meta{date} is the date of the
    day that is currently being processed in ISO format .

    For example, if January 1, 2006 is being processed and the
    calendar has been named |mycal|, then the node containg the |1|
    for this date will be names |mycal-2006-01-01|. You can later
    reference this node.
\begin{codeexample}[]
\begin{tikzpicture}
  \calendar (mycal) [dates=2000-01-01 to 2000-01-31,week list];

  \draw[red] (mycal-2000-01-20) circle (4pt);
\end{tikzpicture}
\end{codeexample}

    \itemoption{day text}|=|\meta{text}
    This option changes the setting of the |\tikzdaytext|. By default,
    this macro simply yields the current day of month, but you can
    change it arbitrarily. Here is a silly example:
\begin{codeexample}[]
\tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,
                day text=x];  
\end{codeexample}
    More useful examples are based on using the |\%| command. This
    command is redefined inside a |\pgfcalendar| to mean the same as
    |\pgfcalendarshorthand|. (The original meaning of |\%| is lost
    inside the calendar, you need to save if before the calendar if
    you really need it.)

    The |\%| inserts the current day/month/year/day of week in a
    certain format into the text. The first letter following the |\%|
    selects the type (permisslbe values are |d|, |m|, |y|, |w|), the
    second letter specifies how the value should be displayed (|-|
    means numerically, |=| means numerically with leading
    space, |0| means numerically with leading zeros, |t| means
    textual, and |.| means textual, abbreviated). For example |\%d0|
    gives the day with a leading zero (for more details see
    the description of |\pgfcalendarshorthand| on
    page~\pageref{pgfcalendarshorthand}).

    Let us redefine the |day text| so that it yields the day with a
    leading zero:
\begin{codeexample}[leave comments]
\tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,
                day text=\%d0];  
\end{codeexample}
    \itemstyle{every day}
    This style is executed by the default node code for each day. The
    default setting is
\begin{codeexample}[code only]
anchor=base east
\end{codeexample}
    The |every day| style is useful for changing the way days
    look. For example, let us make all days red:
\begin{codeexample}[leave comments]
\tikzstyle{every day}+=[red]
\tikz \calendar[dates=2000-01-01 to 2000-01-31,week list];
\end{codeexample}
  \end{itemize}

  \medskip
  \textbf{Changing the appearance of month and year labels.}
  In addition to the days of a calendar, labels for the months and
  even years (for really long calendars) can be added. These labels
  are only added once per month or year and this is not done by
  default. Rather, special styles starting with |month label|
  place these labels and make them visible:
\begin{codeexample}[]
\tikz \calendar[dates=2000-01-01 to 2000-02-last,week list,
                month label above centered];
\end{codeexample}

  The following options change the appearance of the month and year
  label:
  \begin{itemize}
    \itemoption{month code}|=|\meta{code}
    This option allows you to specify what the macro |\tikzmonthcode|
    should expand to.

    By default, the |\tikzmonthcode| it is set to
\begin{codeexample}[code only]
\node[every month]{\tikzmonthtext};
\end{codeexample}
    Note that this node is not named by default.
    \itemoption{month text}|=|\meta{text}
    This option allows you to change the macro |\tikzmonthtext|. By
    default, the month text is a long textual presentation of the
    current month being typeset. 
\begin{codeexample}[leave comments]
\tikz \calendar[dates=2000-01-01 to 2000-01-31,week list,
                month label above centered,  
                month text=\textcolor{red}{\%mt} \%y-];
\end{codeexample}
    \itemstyle{every month}
    This style, which is empty by default, can be used to change the
    appearance of month labels.
    \itemoption{year code}|=|\meta{code} Works like |month code|,
    only for years.
    \itemoption{year text}|=|\meta{text} Works like |month text|,
    only for years.
    \itemstyle{every year} Works like |every month|,
    only for years.
  \end{itemize}
  
  \medskip
  \textbf{Date ifs.}
  Much of the power of the |\calendar| command comes from the use of
  conditionals. There are two equivalent way of specifying such a
  conditional. First, you can add the text
  |if (|\meta{conditions}|) |\meta{code or options} to your
  \meta{calendar specification}, possibly followed by |else|\meta{else
    code or options}. You can have multiple such conditionals (but
  you cannot nest them in this simple manner). The second way is to
  use the following option:
  \begin{itemize}
    \itemoption{if}|=(|\meta{coditions}|)|\meta{code or
      options}\opt{|else|\meta{else code or options}} This option has
    the same effect as giving a corresponding if in the \meta{calendar
      specification}.  The option is mostly useful for use in the
    |every calendar| style, where you cannot provide if conditionals
    otherwise. 
  \end{itemize}
  Now, regardless of how you specify a conditional, it has the
  following effect (individually and independently for each date in
  the calendar):
  \begin{enumerate}
  \item It is checked whether the current date is one of the
    possibilities listed in \meta{coditions}. An example of such a
    condition is |Sunday|. Thus, when you write
    |if (Saturday,Sunday) {foo}|,  then |foo| will be executed for
    every day in the calendar that is a Saturday \emph{or} a Sunday.

    The command |\ifdate| and, thereby, |\pgfcalendarifdate| are used
    to evaluate the \meta{conditions}, see
    page~\pageref{pgfcalendarifdate} for a complete list of possible
    tests. The most useful tests are: Tests like |Monday| and so on,
    |workday| for the days Monday to Friday, |weekend| for Saturday
    and Sunday, |equals| for testing whether the current date equals a
    given date, |at least| and  |at least| for comparing the current
    date with a given date.
  \item If the date passes the check, the \meta{code or options} is
    evaluated in a manner to be described in a moment; if the date
    fails, the \meta{else code or options} is evaluated, if present.

    The \meta{code or options} can either be some code. This is
    indicated by surrounding the code with curly braces. It can also
    be a list of \tikzname\ options. This is indicated by surrounding
    the options with square brackets. For example in the date test
    |if (Sunday) {\draw...} else {\fill...}| there are two pieces of
    code involved. By comparison, |if (Sunday) [red] else [green]|
    involves two options.

    If \meta{code or options} is code, it is simply executed (for the
    current day). If it is a list of options, these options are passed
    to a scope surrounding the current date.
  \end{enumerate}
  Let us now have a look at some examples. First, we use a conditional
  to make all Sundays red.
\begin{codeexample}[]
\tikz
  \calendar
    [dates=2000-01-01 to 2000-01-31,week list]
    if (Sunday) [red];
\end{codeexample}
  Next, let us do something on a specific date:
\begin{codeexample}[]
\tikz
  \calendar
    [dates=2000-01-01 to 2000-01-31,week list]
    if (Sunday)            [red]
    if (equals=2000-01-20) {\draw (0,0) circle (4pt);}
\end{codeexample}

  In the following, more technical information is covered.

  \medskip
  \textbf{The current date scope.}
  As mentioned earlier, for each date in the calendar certain code is
  executed. It is the job of this code to shift around date nodes, to
  render the date nodes, to draw the month labels and to do all other
  stuff that is necessary to draw a calendar.

  The following code is executed for each current date in this order:
  \begin{enumerate}
  \item The before-scope code is executed.
  \item A scope is opened.
  \item The at-begin-scope code is executed.
  \item The all date-ifs from the \meta{calendar specification} are
    executed.
  \item The at-end-scope code is executed.
  \item The scope is closed.
  \item The after-scope code is executed.
  \end{enumerate}
  All of the codes mentioned above can be changed using appropriate
  options, see below. In case you wonder why so many are needed, the
  reason is that the code executed for the different days is not
  surrounded by a scope or \TeX\ group.

  This means that code executed in the before-scope code and in the
  after-scope code has an effect on all following days. For example,
  if the after-scope code modifies the transformation matrix by
  shifting everything downward, all following days will be shifted
  downward. If each day does this, you get a list of days, one below
  the other.

  However, you do not always want code to have an effect on everything
  that follows. For instance, if a day has the date-if
  |if (Sunday) [red]|, we only want this Sunday to red, not all
  following days also. Similarly, sometimes it is easier to compute
  the position of a day relative to a fixed origin and we do not want
  any modifications of the transformation matrix to have an effect
  outside the scope.

  By cleverly adjusting the different codes, all sorts of different
  day arrangements are possible.

  \begin{itemize}
    \itemoption{execute before current date scope}|=|\meta{code} This
    code is executed before everything else for each date. Multiple
    calls of this option have an accumulative effect. Thus, if you use
    this option twice, the code from the first use is used first for
    each day, followed by the code given the second time.
    \itemoption{execute at begin current date scope}|=|\meta{code}
    This code is execute before everything else inside the scope of
    the current date. Again, the effect is accumulative.
    \itemoption{execute at end current date scope}|=|\meta{code}
    This code is executed just before the current date scope is
    closed. The effect is also accumulative, however, in reverse
    order. This is useful to pair, say, |\scope| and |\endscope|
    commands in at-begin- and at-end-code.
    \itemoption{execute after current date scope}|=|\meta{code} This
    is executed at the very end of the current date, outside the
    scope. The accumulation is also in reverse.
  \end{itemize}
\end{command}


\subsection{Day Arrangements}


\subsection{Month Labels}


\subsection{Examples}

In the following, some example calendars are shown that come either
from real applications or are just nice to look at.

Let us start with a year-2100-countdown, in which we cross out dates
as we approach the big celebration. For
this, we set the shape to |strike out| for these dates.

\begin{codeexample}[leave comments]
\begin{tikzpicture}
  \calendar
  [
    dates=2099-12-01 to 2100-01-last,
    week list,inner sep=2pt,month label above centered,
    month text=\%mt \%y0
  ]
  if (at most=2099-12-29) [nodes={strike out,draw}]
  if (weekend)            [black!50,nodes={draw=none}]
  ;
\end{tikzpicture}
\end{codeexample}

The next calendar shows a deadline, which is 10 days in the future
from the current date. The last three days before the deadline are in
red, because we really should be done by then. All days on which we
can no longer work on the project are crossed out.

\begin{codeexample}[leave comments]
\begin{tikzpicture}
  \calendar
  [
    dates=\year-\month-\day+-25 to \year-\month-\day+25,
    week list,inner sep=2pt,month label above centered,
    month text=\textit{\%mt \%y0}
  ]
  if (at least=\year-\month-\day) {}
    else [nodes={strike out,draw}]
  if (at most=\year-\month-\day+7)
    [green!50!black]
  if (between=\year-\month-\day+8 and \year-\month-\day+10)
    [red]
  if (Sunday)
    [gray,nodes={draw=none}]
  ;
\end{tikzpicture}
\end{codeexample}

The following example is a futuristic calendar that is all about circles:

\begin{codeexample}[]
\sffamily

\colorlet{winter}{blue}  
\colorlet{spring}{green!60!black}  
\colorlet{summer}{orange}  
\colorlet{fall}{red}  

% A counter, since TikZ is not clever enough (yet) to handle
% arbitrary angle systems.
\newcount\mycount

\begin{tikzpicture}[transform shape]
  \tikzstyle{every day}=[anchor=mid,font=\fontsize{6}{6}\selectfont]
  \node{\normalsize\the\year};
  \foreach \month/\monthcolor in
    {1/winter,2/winter,3/spring,4/spring,5/spring,6/summer,
     7/summer,8/summer,9/fall,10/fall,11/fall,12/winter}
  {
    % Computer angle:
    \mycount=\month
    \advance\mycount by -1
    \multiply\mycount by 30
    \advance\mycount by -90

    % The actual calendar
    \calendar at (\the\mycount:6.4cm)
    [
      dates=\the\year-\month-01 to \the\year-\month-last,
    ]
    if (day of month=1) {\color{\monthcolor}\tikzmonthcode}
    if (Sunday) [red]
    if (all) 
    {
      % Again, compute angle
      \mycount=1
      \advance\mycount by -\pgfcalendarcurrentday
      \multiply\mycount by 11
      \advance\mycount by 90
      \pgftransformshift{\pgfpointpolar{\mycount}{1.4cm}}
    };
  }
\end{tikzpicture}
\end{codeexample}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "pgfmanual-pdftex-version"
%%% End: 
